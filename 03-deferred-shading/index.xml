<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>03-deferred-shadings on OpenGL Avancé</title>
    <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/index.xml</link>
    <description>Recent content in 03-deferred-shadings on OpenGL Avancé</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <lastBuildDate>Thu, 29 Dec 2016 12:02:34 +0100</lastBuildDate>
    <atom:link href="https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Deferred Shading</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/</link>
      <pubDate>Thu, 29 Dec 2016 12:02:34 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/</guid>
      <description>

&lt;h1 id=&#34;deferred-shading&#34;&gt;Deferred Shading&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Pipeline de rendu</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/pipeline/</link>
      <pubDate>Thu, 29 Dec 2016 12:27:04 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/pipeline/</guid>
      <description>

&lt;h2 id=&#34;un-problème&#34;&gt;Un problème ?&lt;/h2&gt;

&lt;p&gt;Un problème bien connu du &lt;em&gt;forward shading&lt;/em&gt; est le traitement par le fragment shader de fragments qui ne seront pas visible à l&amp;rsquo;écran.
Tous les fragment occultés par d&amp;rsquo;autre fragments sont traités car le fragment shader peut potentiellement modifier la profondeur des fragments et donc les rendre visible.
Ainsi, si le fragment shader est complexe, tous ces calculs inutiles peuvent devenir couteux.&lt;/p&gt;

&lt;p&gt;En plus de cela, il est assez difficile en une seule passe de rendu de pouvoir optimiser son algorithme pour faire moins de calcul.
Un exemple simple est l&amp;rsquo;utilisation d&amp;rsquo;un grand nombre de lumières n&amp;rsquo;émettant que dans un volume réduit de la scène.
Ce type de lumière affecte assez peu de pixels.
Avec un forward renderer, il n&amp;rsquo;y a que dans le fragment shader qu&amp;rsquo;on peut s&amp;rsquo;appercevoir qu&amp;rsquo;une lumière donnée n&amp;rsquo;affecte pas le fragment, c&amp;rsquo;est déjà trop tard.
En ayant accès à plus d&amp;rsquo;information sur la géométrie visible par la caméra, il est possible d&amp;rsquo;affecter rapidement des listes de lumières à des tiles de pixel et ainsi de passer moins de temps globalement dans le fragment shader.&lt;/p&gt;

&lt;p&gt;Le deferred rendering est un autre algorithme de rendu permettant de palier à ces problèmes.&lt;/p&gt;

&lt;h2 id=&#34;le-deferred-shading&#34;&gt;Le Deferred Shading&lt;/h2&gt;

&lt;p&gt;Le principe du deferred est de découpler le traitement de la géométrie (vertex buffer + rasterisation) du traitement des fragments (shading dans le fragment shader).&lt;/p&gt;

&lt;p&gt;Une première passe de rendu dessine donc tous les objets de la scène, mais plutot que de les illuminer dans le fragment shader, elle écrit les informations de chaque fragment dans des textures.
Ces informations sont celles utilisées pour le lighting: position, normale et texCoords du fragment, mais également paramètres de matériaux (ambiant, diffus, glossy et shininess).
Comme ces informations sont majoritairement de nature géométrique, l&amp;rsquo;ensemble des textures de sortie est généralement appelé &lt;strong&gt;GBuffer&lt;/strong&gt; et cette première passe de rendu s&amp;rsquo;appelle la &lt;strong&gt;Geometry Pass&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Une fois la première passe accomplie et le GBuffer remplit, on effectue la &lt;strong&gt;Shading Pass&lt;/strong&gt;, qui consiste à utiliser le GBuffer pour illuminer chaque pixel.
Au cours de cette passe, on dessiner simplement un quad couvrant l&amp;rsquo;écran, le vertex shader ne fait donc quasiment rien.
Au contraire, le fragment shader lit dans les textures du GBuffer les informations du pixel courant (qui ont été enregistré pendant la geometry pass) et calcule la couleur finale à partir de ces infos et des lumières de la scène.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;image ci-dessous montre en haut un rendu final, résultat de la Shading Pass appliquée au GBuffer donc les textures sont montrés en bas:
&lt;img src=&#34;https://Celeborn2BeAlive.github.io/opengl-avance/images/gbuffer_1.png&#34; alt=&#34;GBuffer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A noter qu&amp;rsquo;il y énormément de manière de remplir un GBuffer en fonction des performances voulues.
Pour ces TPs, on se contentera d&amp;rsquo;écrire tous les informations dont on a besoin pour le lighting, sans chercher à optimiser.&lt;/p&gt;

&lt;h2 id=&#34;liens&#34;&gt;Liens&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342&#34;&gt;Explication des deux approches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html&#34;&gt;Tuto OpenGL Dev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Geometry pass</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/geometry-pass/</link>
      <pubDate>Thu, 29 Dec 2016 12:27:23 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/geometry-pass/</guid>
      <description>

&lt;p&gt;Comme indiqué en introduction, la première passe de rendu est la Geometry Pass, dont l&amp;rsquo;objectif est de &amp;ldquo;dessiner&amp;rdquo; dans un GBuffer les informations concernant les objets visible à l&amp;rsquo;écran.&lt;/p&gt;

&lt;p&gt;Pour cela, il va falloir créer les textures OpenGL destinées à contenir ces informations, et les attacher à un &lt;strong&gt;framebuffer object&lt;/strong&gt;, qui va permettre d&amp;rsquo;écrire dans ces textures plutot qu&amp;rsquo;a l&amp;rsquo;écran.&lt;/p&gt;

&lt;p&gt;Pour ces TPs, dupliquez l&amp;rsquo;app de l&amp;rsquo;exercice du foward renderer afin d&amp;rsquo;avoir une scene chargée et stockée sur GPU pour être rendue.
Nommez la nouvelle app &amp;ldquo;deferred-renderer&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;shaders&#34;&gt;Shaders&lt;/h2&gt;

&lt;p&gt;Nous allons commencer par les shaders car c&amp;rsquo;est le plus simple.
Renommez les shaders &lt;em&gt;forward.vs.glsl&lt;/em&gt; et &lt;em&gt;forward.fs.glsl&lt;/em&gt; en &lt;em&gt;geometryPass.vs.glsl&lt;/em&gt; et &lt;em&gt;geometryPass.fs.glsl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Il faut ensuite modifier le fragment shader (plus exactement le simplifier).&lt;/p&gt;

&lt;p&gt;Tout d&amp;rsquo;abors modifier les sorties. On avait:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;out vec3 fColor;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a remplacer par:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;layout(location = 0) out vec3 fPosition;
layout(location = 1) out vec3 fNormal;
layout(location = 2) out vec3 fAmbient;
layout(location = 3) out vec3 fDiffuse;
layout(location = 4) out vec4 fGlossyShininess;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On va donc écrire dans 5 textures en tout.&lt;/p&gt;

&lt;p&gt;Dans le main du shader, remplacez tout le code d&amp;rsquo;illumination par des écritures dans les variables de sortie. Ne pas oublier de normaliser &lt;em&gt;vViewSpaceNormal&lt;/em&gt; avant de l&amp;rsquo;écrire dans &lt;em&gt;fNormal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A noter que l&amp;rsquo;on écrit pas les texCoords en sortie car on ne les utilise que pour lire les coefficients ambiant, diffus et glossy des textures de l&amp;rsquo;objet en cours de rendu. Les texCoords ne sont donc pas necessaire à la Shading Pass puisqu&amp;rsquo;on écrit directement ces coefficients dans des textures du GBuffer.&lt;/p&gt;

&lt;p&gt;Les variables de sortie de matériaux doivent stocker la multiplication du coefficient associé avec la valeur lue dans la texture. Par exemple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform vec3 uKd;
uniform sampler2D uKdSampler;

[...]

// Dans le main:
vec3 kd = uKd * vec3(texture(uKdSampler, vTexCoords));
fDiffuse = kd;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enfin, il faut packer la shininess dans le canal alpha de la variable de sortie &lt;em&gt;fGlossyShininess&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Dans le code de Application, chargez ces shaders pour tester leur compilation.&lt;/p&gt;

&lt;h2 id=&#34;textures-du-gbuffer&#34;&gt;Textures du GBuffer&lt;/h2&gt;

&lt;p&gt;Dans la classe Application, déclarez un tableau de &lt;em&gt;GLuint&lt;/em&gt; pour stocker les texture objects, ainsi que l&amp;rsquo;enum suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum GBufferTextureType
{
    GPosition = 0,
    GNormal,
    GAmbient,
    GDiffuse,
    GGlossyShininess,
    GDepth, // On doit créer une texture de depth mais on écrit pas directement dedans dans le FS. OpenGL le fait pour nous (et l&#39;utilise).
    GBufferTextureCount
};
GLuint m_GBufferTextures[GBufferTextureCount];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans le constructeur, créer et initialiser ces textures avec comme dimension la taille de la fenêtre.&lt;/p&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;Vous pouvez créer toutes les textures en un seul appel à glGenTextures (ou glCreateTextures en DSA) car nos identifiants sont stockés dans un tableau. Il suffit de passer à la fonction le nombre de textures à créer.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Le format à passer à &lt;em&gt;glTexStorage2D&lt;/em&gt; dépend du type de texture, vous pouvez utiliser le tableau suivant, en correspondance avec l&amp;rsquo;enum:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const GLenum m_GBufferTextureFormat[GBufferTextureCount] = { GL_RGB32F, GL_RGB32F, GL_RGB32F, GL_RGB32F, GL_RGBA32F, GL_DEPTH_COMPONENT32F };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il est inutile de remplir les textures avec &lt;em&gt;glTexSubImage2D&lt;/em&gt; car elles sont destinées à être remplies par le fragment shader.&lt;/p&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenTextures&lt;/td&gt;
&lt;td&gt;glCreateTextures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindTexture(GL_TEXTURE_2D, texID)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glTexStorage2D&lt;/td&gt;
&lt;td&gt;glTextureStorage2D&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;framebuffer-object&#34;&gt;Framebuffer object&lt;/h2&gt;

&lt;p&gt;Déclarez une variable &lt;em&gt;GLuint m_FBO&lt;/em&gt; dans la classe Application.&lt;/p&gt;

&lt;p&gt;Dans le constructeur, après création des texture objects, créez le FBO (&lt;em&gt;glGenFramebuffers&lt;/em&gt;) et bindez le sur la cible &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Il faut ensuite attacher toutes nos textures au FBO en utilisant la fonction &lt;em&gt;glFramebufferTexture2D&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;glFramebufferTexture2D( GLenum target,
    GLenum attachment,
    GLenum textarget,
    GLuint texture,
    GLint level);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La target est la cible sur laquelle est bindée de FBO (&lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;attachment est un point d&amp;rsquo;attache de la forme &lt;em&gt;GL_COLOR_ATTACHMENT0 + i&lt;/em&gt;, ou &lt;em&gt;i&lt;/em&gt; est l&amp;rsquo;index de la texture dans son tableau (de &lt;em&gt;GPosition&lt;/em&gt; à &lt;em&gt;GGlossyShininess&lt;/em&gt;).
Pour la texture de profondeur (&lt;em&gt;GDepth&lt;/em&gt;), elle doit être attachée sur le point &lt;em&gt;GL_DEPTH_ATTACHMENT&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Dans notre cas, &lt;em&gt;textarget&lt;/em&gt; doit être mis à &lt;em&gt;GL_TEXTURE_2D&lt;/em&gt; car toutes nos textures sont 2D (on pourrait aussi faire le rendu dans des layers de textures 3D, il faudrait alors changer ce paramètre).&lt;/p&gt;

&lt;p&gt;Enfin, &lt;em&gt;level&lt;/em&gt; doit être mis à 0 (c&amp;rsquo;est le niveau de mipmap dans lequel dessiner).&lt;/p&gt;

&lt;p&gt;Une fois les textures attachées, il faut indiquer à OpenGL une association &amp;ldquo;sortie du fragment shader&amp;rdquo; vers texture.
Comme vous le verrez au prochain exercice, le fragment shader peut avoir plusieurs sorties indicées avec des &lt;em&gt;layout(location = i)&lt;/em&gt; (de la meme manière que les entrée du vertex shader).
Il faut dire à OpenGL comment les locations doivent être connectées aux textures du FBO.&lt;/p&gt;

&lt;p&gt;Cela passe par la fonction &lt;em&gt;glDrawBuffers&lt;/em&gt;, qui prend le nombre de sorties du fragment shader et un tableau de &lt;em&gt;GL_COLOR_ATTACHMENTi&lt;/em&gt; afin de faire la liaison. Nous allons faire assez simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;GLenum drawBuffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4 };
glDrawBuffers(6, drawBuffers);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ici on va envoyer la sortie &lt;em&gt;i&lt;/em&gt; du fragment shader vers l&amp;rsquo;attachment &lt;em&gt;GL_COLOR_ATTACHMENTi&lt;/em&gt; du FBO.
C&amp;rsquo;est ce qui parait le plus logique mais, si on voulait, on pourrait tout à fait envoyer la sortie 3 du fragment shader vers la texture attachée sur GL_COLOR_ATTACHMENT0, par exemple.&lt;/p&gt;

&lt;p&gt;Utilisez ensuite la fonction &lt;em&gt;glCheckFramebufferStatus&lt;/em&gt; afin de vérifier si le framebuffer créé est correct (si ce n&amp;rsquo;est pas le cas, bon debug !).&lt;/p&gt;

&lt;p&gt;Enfin débindez le framebuffer de la cible &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenFramebuffers&lt;/td&gt;
&lt;td&gt;glCreateFramebuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glFramebufferTexture2D&lt;/td&gt;
&lt;td&gt;glNamedFramebufferTexture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glDrawBuffers&lt;/td&gt;
&lt;td&gt;glNamedFramebufferDrawBuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glCheckFramebufferStatus&lt;/td&gt;
&lt;td&gt;glCheckNamedFramebufferStatus&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;boucle-de-rendu&#34;&gt;Boucle de rendu&lt;/h2&gt;

&lt;p&gt;Au rendu assez peu de chose à changer.&lt;/p&gt;

&lt;p&gt;Avant de dessiner, binder le framebuffer sur la cible &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;. Cela va indiquer à OpenGL que le fragment shader va écrire dans les textures attachées au FBO.&lt;/p&gt;

&lt;p&gt;Il faut également faire un &lt;em&gt;.use()&lt;/em&gt; sur le programme correspondant au aux &lt;em&gt;geometryPass.glsl&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Après le dessin de la scène, débindez le FBO. Voila.&lt;/p&gt;

&lt;p&gt;Pour tester que tout fonctionne bien, on peut blitter les textures du GBuffer à l&amp;rsquo;écran.&lt;/p&gt;

&lt;p&gt;Après le débind du FBO, rebindez le, cette fois ci sur la cible &lt;em&gt;GL_READ_FRAMEBUFFER&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Utilisez ensuite la fonction &lt;em&gt;glReadBuffer&lt;/em&gt;, qui prend en paramètre un &lt;em&gt;GL_COLOR_ATTACHMENT0 + i&lt;/em&gt;, correspondant à la texture du GBuffer que vous voulez afficher. Vous pouvez par example afficher la texture de normals en passant &lt;em&gt;GL_COLOR_ATTACHMENT0 + GNormal&lt;/em&gt;. Faites ensuite en sorte de pouvoir choisir la texture à afficher via la GUI (avec des boutons radio, &lt;em&gt;ImgGui::RadioButton&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Puis utilisez la fonction &lt;em&gt;glBlitFramebuffer&lt;/em&gt; qui permet de &amp;ldquo;copier-coller&amp;rdquo; (avec filtre) une portion du FBO bindé sur &lt;em&gt;GL_READ_FRAMEBUFFER&lt;/em&gt; vers le FBO bindé sur &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt; (c&amp;rsquo;est à dire l&amp;rsquo;écran, lorsque rien n&amp;rsquo;est bindé dessus).&lt;/p&gt;

&lt;p&gt;Finalement, débindez le FBO de &lt;em&gt;GL_READ_FRAMEBUFFER&lt;/em&gt;. A noter qu&amp;rsquo;en DSA il n&amp;rsquo;y a rien à binder pour l&amp;rsquo;étape du blit (il faut quand même binder sur &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt; avant de dessiner la scène).&lt;/p&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glReadBuffer&lt;/td&gt;
&lt;td&gt;glNamedFramebufferReadBuffer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBlitFramebuffer&lt;/td&gt;
&lt;td&gt;glBlitNamedFramebuffer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Shading pass</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/shading-pass/</link>
      <pubDate>Thu, 29 Dec 2016 12:27:28 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/shading-pass/</guid>
      <description>

&lt;p&gt;Il faut maintenant coder la shading pass, qui a pour role d&amp;rsquo;illuminer chaque pixel en utilisant les textures du GBuffer qui viennents se substituer aux variables d&amp;rsquo;entrées du fragment shader d&amp;rsquo;un forward renderer.&lt;/p&gt;

&lt;h2 id=&#34;shaders&#34;&gt;Shaders&lt;/h2&gt;

&lt;p&gt;Créez deux nouveaux shaders &lt;em&gt;shadingPass.vs.glsl&lt;/em&gt; et &lt;em&gt;shadingPass.fs.glsl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Le VS est destiner à traiter un simple quad en 2D couvrant tout l&amp;rsquo;écran, tout ce passera dans le FS.
Voici donc le code du VS:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;#version 330

layout(location = 0) in vec2 aPosition;

void main()
{
    gl_Position =  vec4(aPosition, 0, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pour le FS c&amp;rsquo;est un peu plus compliqué, mais vous pouvez repartir de celui du forward renderer.
Il faut simplement remplacer les variables &lt;em&gt;in&lt;/em&gt; et les lectures dans les textures de matériaux par des lectures dans les textures du GBuffer.&lt;/p&gt;

&lt;p&gt;On ajoute donc les uniforms suivantes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform sampler2D uGPosition;
uniform sampler2D uGNormal;
uniform sampler2D uGAmbient;
uniform sampler2D uGDiffuse;
uniform sampler2D uGlossyShininess;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;qu&amp;rsquo;il faut utiliser dans le main du shader pour récupérer les infos géométrique du fragment et les infos de matériaux.
Pour lire dans les textures du GBuffer, il faut utiliser la fonction GLSL &lt;em&gt;texelFetch&lt;/em&gt; ainsi que la variable built-in &lt;em&gt;gl_FragCoord&lt;/em&gt; contenant les coordonnées du pixel courant. Exemple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;vec3 position = vec3(texelFetch(uGPosition, ivec2(gl_FragCoord.xy), 0)); // Correspond a vViewSpacePosition dans le forward renderer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensuite l&amp;rsquo;algorithme pour calculer la couleur du fragment à partir des lights reste le meme.&lt;/p&gt;

&lt;p&gt;Dans le code de l&amp;rsquo;application, chargez et compilez vos deux shaders dans un second programme GLSL afin de vérifier que vous n&amp;rsquo;avez pas fait d&amp;rsquo;erreur de syntaxe. On utilisera ce nouveau programme par la suite dans la boucle de rendu.&lt;/p&gt;

&lt;p&gt;A l&amp;rsquo;initialisation, récupérez les locations des nouvelles uniformes (ainsi que des anciennes, mettez à jour le programme concerné puisqu&amp;rsquo;on en a deux maintenant).&lt;/p&gt;

&lt;h2 id=&#34;un-quad-ou-un-triangle-voir-la-note&#34;&gt;Un Quad (ou un triangle, voir la note)&lt;/h2&gt;

&lt;p&gt;Afin de &amp;ldquo;lancer&amp;rdquo; la Shading Pass et pouvoir passer dans le fragment shader pour calculer la couleur de nos pixels, il faut un truc à dessiner à l&amp;rsquo;écran. Puisque toute la géometrie visible depuis la caméra est déjà encodée dans le GBuffer, il suffira juste de dessiner un quad couvrant tout l&amp;rsquo;écran pour pouvoir parcourir tous les pixels du GBuffer et faire notre traitement.&lt;/p&gt;

&lt;p&gt;Dans la classe Application, ajoutez un nouveau VBO, IBO et VAO. Faite en sorte que ces trois objets stockent ce qu&amp;rsquo;il faut pour dessiner un quad en 2D sur tout l&amp;rsquo;ecran (de -1 à 1 sur chacun des axes). Il n&amp;rsquo;y a que l&amp;rsquo;attribut de position à envoyer.&lt;/p&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;Plutot que de dessiner un quad, qui comporte deux triangle, il est également possible de dessiner un triangle couvrant plus que tout les écrans. L&amp;rsquo;ensemble des pixels du triangle en dehors de l&amp;rsquo;écran seront discardés avant même d&amp;rsquo;arriver dans le fragment shader.
Les coordonnées d&amp;rsquo;un tel triangle peuvent etres les suivantes: (-1, -1), (3, -1), (-1, 3).
Dessinez le sur papier pour vous en convaincre.
Dans le cas d&amp;rsquo;un triangle, pas besoin d&amp;rsquo;IBO, on peut directement appeler &lt;em&gt;glDrawArrays&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenBuffers&lt;/td&gt;
&lt;td&gt;glCreateBuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glGenVertexArrays&lt;/td&gt;
&lt;td&gt;glCreateVertexArrays&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindBuffer(GL_ARRAY_BUFFER, vboID)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBufferStorage&lt;/td&gt;
&lt;td&gt;glNamedBufferStorage&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;glVertexArrayVertexBuffer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;glVertexArrayAttribBinding&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glEnableVertexAttribArray&lt;/td&gt;
&lt;td&gt;glEnableVertexArrayAttrib&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glVertexAttribPointer&lt;/td&gt;
&lt;td&gt;glVertexArrayAttribFormat&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboID)&lt;/td&gt;
&lt;td&gt;glVertexArrayElementBuffer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;au-rendu&#34;&gt;Au Rendu&lt;/h2&gt;

&lt;p&gt;Dans la boucle de rendu, remplacez le blit des textures du GBuffer de l&amp;rsquo;exercice précédent par les étapes suivantes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;.use()&lt;/em&gt; sur le programme de la shading pass&lt;/li&gt;
&lt;li&gt;set des uniforms de light (point light et directional light, qui sont normalement dans le fragment shader de la shading pass)&lt;/li&gt;
&lt;li&gt;binding des textures du GBuffer sur différentes texture units (de 0 à 4 inclut)&lt;/li&gt;
&lt;li&gt;set des uniforms correspondant aux textures du GBuffer (chacune avec l&amp;rsquo;indice de la texture unit sur laquelle la texture correspondante est bindée)&lt;/li&gt;
&lt;li&gt;dessin du quad/triangle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fonctions OpenGL à utiliser au rendu:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;glUniform3fv, glUniform1i&lt;/li&gt;
&lt;li&gt;glActiveTexture&lt;/li&gt;
&lt;li&gt;glBindTexture&lt;/li&gt;
&lt;li&gt;glBindVertexArray&lt;/li&gt;
&lt;li&gt;glDrawElements (ou glDrawArrays si triangle)&lt;/li&gt;
&lt;li&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Après ça vous devriez retrouver le rendu que vous aviez avec le forward renderer.&lt;/p&gt;

&lt;p&gt;Vous pouvez essayer de charger de grosse scènes (ou génération aléatoire de plein de géométrie) pour comparer les performances des deux méthodes de rendu.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aller plus loin</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/plus-loin/</link>
      <pubDate>Wed, 04 Jan 2017 00:58:16 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/plus-loin/</guid>
      <description>

&lt;p&gt;Voici plusieurs choses améliorable pour rendre notre deferred renderer plus interessant:&lt;/p&gt;

&lt;h2 id=&#34;compute-shader-pour-la-shading-pass&#34;&gt;Compute Shader pour la Shading Pass&lt;/h2&gt;

&lt;p&gt;Dessiner un quad pour la shading pass, c&amp;rsquo;est en réalité se compliquer la vie pour rien. Tout ce qu&amp;rsquo;on veut c&amp;rsquo;est traiter chacun des pixels du GBuffer, en parallèle sur GPU. D&amp;rsquo;une certaine manière, ce qu&amp;rsquo;on aimerait faire c&amp;rsquo;est un genre de kernel Cuda.&lt;/p&gt;

&lt;p&gt;Ca tombe bien, les compute shaders (dispo depuis OpenGL 4.3) permettent exactement de faire ça.&lt;/p&gt;

&lt;p&gt;Trouvez vous un tuto sur le net sur les compute shaders et essayez d&amp;rsquo;adapter votre shading pass pour utiliser un CS plutot que dessin quad + VS + FS.&lt;/p&gt;

&lt;h2 id=&#34;light-culling-simple&#34;&gt;Light Culling simple&lt;/h2&gt;

&lt;p&gt;Il est assez facile en deferred de faire le rendu de la contribution de plusieurs lights en accumulant le résultat de plusieurs shading pass.&lt;/p&gt;

&lt;p&gt;De plus, avec des lights dont l&amp;rsquo;interaction est limités dans l&amp;rsquo;espace (point light avec un radius par exemple), il est possible de remplacer le dessin du Quad par une forme quelquonque qui vient couvrir en espace ecran la forme du volume projeté de la light. On traite ainsi moins de pixels a chaque shading pass et on gagne du temps. Les &lt;a href=&#34;http://ogldev.atspace.co.uk/www/tutorial36/tutorial36.html&#34;&gt;parties 2 et 3&lt;/a&gt; du tutorial d&amp;rsquo;ogldev détaillent cette méthode. Implémentez là.&lt;/p&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Ces deux exercices sont un peu antagonistes. Dans le premier on remplace le dessin du Quad par l&amp;rsquo;execution d&amp;rsquo;un compute shader.
Dans le deuxième on remplace le dessin du Quad par des dessins de différents formes.&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;conclusion-et-forward&#34;&gt;Conclusion et Forward +&lt;/h2&gt;

&lt;p&gt;Ces deux premiers TPs vous ont permis d&amp;rsquo;implémenter les deux pipelines de rendu temps réel les plus utilisé: forward et deferred.&lt;/p&gt;

&lt;p&gt;Ils ont tous les deux des avantages et inconvénients:&lt;/p&gt;

&lt;h3 id=&#34;forward&#34;&gt;Forward&lt;/h3&gt;

&lt;p&gt;Avantages:
- Simple a mettre en oeuvre, un seul programme GLSL
- Accès aux propriétés de l&amp;rsquo;objet en cours de rendu au moment de l&amp;rsquo;illumination via les uniforms
- Possibilité d&amp;rsquo;exploiter les techniques d&amp;rsquo;anti-aliasing du GPU&lt;/p&gt;

&lt;p&gt;Désavantages:
- Potentiellement beaucoup de fragment traités puis occultés
- Pas d&amp;rsquo;information globale sur l&amp;rsquo;ensemble de la géométrie visible (en tout cas pas sans précalcul)&lt;/p&gt;

&lt;h3 id=&#34;deferred&#34;&gt;Deferred&lt;/h3&gt;

&lt;p&gt;Avantages:
- Possibilité d&amp;rsquo;utiliser le GBuffer pour faire du light culling, post-process ou autre
- Shading pass seulement sur les fragments non occultés -&amp;gt; gain de perfs si shading pass couteuse (souvent le cas)&lt;/p&gt;

&lt;p&gt;Désavantages:
- Gourmand en mémoire et bande passante (grosse résolution = grosses textures à sortir, vive la 4K et la VR !)
- Pour avoir accès a des informations sur les objets à rendre dans la shading pass, il faut les écrire dans des textures -&amp;gt; difficile de mélanger différent modèles de shading sur un meme rendu
- Par defaut, impossible de rendre des objets transparents&lt;/p&gt;

&lt;h3 id=&#34;forward-1&#34;&gt;Forward +&lt;/h3&gt;

&lt;p&gt;Une autre méthode a été développé par AMD, appelé Forward + (&lt;a href=&#34;http://www.gdcvault.com/play/1016435/Forward-Rendering-Pipeline-for-Modern&#34;&gt;voir ici&lt;/a&gt; et &lt;a href=&#34;http://fr.slideshare.net/takahiroharada/forward-34779335&#34;&gt;la&lt;/a&gt;), qui tente d&amp;rsquo;obtenir les avantages des deux méthodes sans les inconvénients.&lt;/p&gt;

&lt;p&gt;Sans trop entrer dans les détails, voici le fonctionnement général de l&amp;rsquo;algo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;depth pré-pass: rendu uniquement du depth buffer&lt;/li&gt;
&lt;li&gt;light culling: utilisation du depth buffer pour associer les lights à des tiles de pixels&lt;/li&gt;
&lt;li&gt;lighting: rendu en forward, mais utilisation du depth buffer précalculé pour discard les fragments occultés, + utilisation des lights associés aux tiles de pixels&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>