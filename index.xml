<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OpenGL Avancé</title>
    <link>https://celeborn2bealive.github.io/opengl-avance/index.xml</link>
    <description>Recent content on OpenGL Avancé</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <lastBuildDate>Thu, 19 Jan 2017 23:51:42 +0100</lastBuildDate>
    <atom:link href="https://celeborn2bealive.github.io/opengl-avance/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Qu&#39;est ce que OpenGL ?</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/06-course/opengl-context/</link>
      <pubDate>Thu, 19 Jan 2017 23:51:42 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/06-course/opengl-context/</guid>
      <description>

&lt;p&gt;OpenGL est une &lt;a href=&#34;https://www.wikiwand.com/en/Application_programming_interface&#34;&gt;API&lt;/a&gt; permettant d&amp;rsquo;effectuer du calcul parallèle sur GPU, principalement orienté sur la rasterisation de primitives simples (points, lignes et triangles) afin de les afficher dans une image.&lt;/p&gt;

&lt;p&gt;OpenGL &lt;strong&gt;n&amp;rsquo;est pas&lt;/strong&gt; une bibliothèque, mais simplement une &lt;a href=&#34;https://www.opengl.org/registry/doc/glspec45.core.pdf&#34;&gt;spécification&lt;/a&gt; de fonctions permettant l&amp;rsquo;utilisation d&amp;rsquo;effectuer différent de taches de manière asynchrones, souvent centrées autour de la programmation graphique.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.khronos.org/&#34;&gt;Khronos&lt;/a&gt; est le groupe chargé d&amp;rsquo;établir la spécification de chaque version d&amp;rsquo;OpenGL. Plusieurs &lt;a href=&#34;https://www.khronos.org/members/list&#34;&gt;entreprises/universités/personnes&lt;/a&gt; font partie de ce groupe afin de faire avancer la spécification et s&amp;rsquo;adapter à l&amp;rsquo;évolution de l&amp;rsquo;architecture du hardware.&lt;/p&gt;

&lt;p&gt;Les constructeurs de cartes graphiques implémentent ensuite cette spécification à travers un driver. Ainsi, pour faire de l&amp;rsquo;OpenGL sur sa carte graphique, il suffit d&amp;rsquo;installer un driver récent depuis le site du constructeur ou depuis le gestionnaire de paquet.&lt;/p&gt;

&lt;p&gt;Il est tout à fait possible d&amp;rsquo;implémenter l&amp;rsquo;ensemble des fonctions OpenGL dans une bibliothèque tournant sur CPU, c&amp;rsquo;est par exemple le cas de &lt;a href=&#34;http://www.mesa3d.org/&#34;&gt;MESA&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;contexte-opengl&#34;&gt;Contexte OpenGL&lt;/h2&gt;

&lt;p&gt;Le contexte OpenGL stocke l&amp;rsquo;ensemble des données OpenGL pour votre application (ensemble des variables d&amp;rsquo;état, tel que le status d&amp;rsquo;activation du depth test, et les objets créés).&lt;/p&gt;

&lt;p&gt;La création du contexte OpenGL se fait le plus souvent à l&amp;rsquo;ouverture d&amp;rsquo;une fenêtre, par la bibliothèque bas niveau de gestion de fenêtre du systeme (X ou Wayland sous Linux, &lt;a href=&#34;https://www.khronos.org/opengl/wiki/Creating_an_OpenGL_Context_(WGL)&#34;&gt;la Win32 API sous Windows&lt;/a&gt;, etc.).&lt;/p&gt;

&lt;p&gt;On n&amp;rsquo;a généralement pas à s&amp;rsquo;en occuper puisqu&amp;rsquo;il est courant de passer par une lib plus haur niveau de fenêtrage (SDL, GLFW, Qt, &amp;hellip;).&lt;/p&gt;

&lt;p&gt;Plus d&amp;rsquo;informations sur le Wiki:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/OpenGL_Context&#34;&gt;https://www.khronos.org/opengl/wiki/OpenGL_Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Core_And_Compatibility_in_Contexts&#34;&gt;https://www.khronos.org/opengl/wiki/Core_And_Compatibility_in_Contexts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Get_Context_Info&#34;&gt;https://www.khronos.org/opengl/wiki/Get_Context_Info&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;calcul-asynchrone&#34;&gt;Calcul Asynchrone&lt;/h2&gt;

&lt;p&gt;Il est important de bien comprendre que les fonction de rendu (glDraw*) OpenGL sont généralement asynchrone. Cela signifie qu&amp;rsquo;elles ne sont pas executées immédiatement mais placées dans une command queue en attendant d&amp;rsquo;être executées par le GPU.&lt;/p&gt;

&lt;p&gt;Cela permet au driver d&amp;rsquo;optimiser l&amp;rsquo;utilisation du GPU, et à l&amp;rsquo;application de pouvoir faire autre chose pendant que le GPU calcule.&lt;/p&gt;

&lt;p&gt;La synchronisation entre CPU et GPU peut se faire implicitement via l&amp;rsquo;appel à certaines fonctions qui necessitent que le rendu soit terminé (glfwSwapBuffers), ou explicitement à l&amp;rsquo;aide des fonctions glFinish et glFlush.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Synchronization&#34;&gt;https://www.khronos.org/opengl/wiki/Synchronization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;chargement-des-fonctions-opengl-core-profile&#34;&gt;Chargement des fonctions OpenGL Core Profile&lt;/h2&gt;

&lt;p&gt;OpenGL a un fonctionnement un peu particulier dans le sens ou il n&amp;rsquo;existe pas de header déclarant l&amp;rsquo;ensemble des fonctions OpenGL du core profile (i.e. OpenGL 3+).&lt;/p&gt;

&lt;p&gt;Le header GL.h ne déclare qu&amp;rsquo;un nombre restreint de fonctions, principalement celles du compatibility profiles, dépréciées (glBegin, glEnd, glVertex3f, etc.).&lt;/p&gt;

&lt;p&gt;Pour pouvoir appeler les fonctions OpenGL 3+, il faut demander à la lib de fenetrage bas niveau des pointeurs de fonctions sur chacune de celles que l&amp;rsquo;on veut utiliser.&lt;/p&gt;

&lt;p&gt;Comme c&amp;rsquo;est une tache particulièrement ennuyante, répétitive et ininteressante, on passe généralement par une bibliothèque dediée qui va charger tous les pointeurs de fonction d&amp;rsquo;un coup et nous les exposer dans des variables globales.&lt;/p&gt;

&lt;p&gt;La lib la plus utilisée est sans doute &lt;a href=&#34;http://glew.sourceforge.net/&#34;&gt;GLEW&lt;/a&gt;, mais je vous recommande chaudement &lt;a href=&#34;http://glad.dav1d.de/&#34;&gt;GLAD&lt;/a&gt; qui à les avantages suivants:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;facile à compiler et linker, aussi bien sous windows que sous linux&lt;/li&gt;
&lt;li&gt;possibilité de customiser entièrement ce qu&amp;rsquo;elle contient via le site (choix de la version d&amp;rsquo;OpenGL, choix du profile, ajout d&amp;rsquo;extensions, etc.)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/05-post-processing/introduction/</link>
      <pubDate>Thu, 29 Dec 2016 12:35:23 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/05-post-processing/introduction/</guid>
      <description>&lt;p&gt;Lorem Ipsum&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/introduction/</link>
      <pubDate>Thu, 29 Dec 2016 12:29:08 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/introduction/</guid>
      <description>

&lt;h2 id=&#34;principe-général&#34;&gt;Principe général&lt;/h2&gt;

&lt;p&gt;todo.&lt;/p&gt;

&lt;h2 id=&#34;création-de-la-shadow-map&#34;&gt;Création de la Shadow Map&lt;/h2&gt;

&lt;p&gt;todo.&lt;/p&gt;

&lt;h2 id=&#34;utilisation-de-la-shadow-map&#34;&gt;Utilisation de la Shadow Map&lt;/h2&gt;

&lt;p&gt;todo.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pipeline de rendu</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/pipeline/</link>
      <pubDate>Thu, 29 Dec 2016 12:27:04 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/pipeline/</guid>
      <description>

&lt;h2 id=&#34;un-problème&#34;&gt;Un problème ?&lt;/h2&gt;

&lt;p&gt;Un problème bien connu du &lt;em&gt;forward shading&lt;/em&gt; est le traitement par le fragment shader de fragments qui ne seront pas visible à l&amp;rsquo;écran.
Tous les fragment occultés par d&amp;rsquo;autre fragments sont traités car le fragment shader peut potentiellement modifier la profondeur des fragments et donc les rendre visible.
Ainsi, si le fragment shader est complexe, tous ces calculs inutiles peuvent devenir couteux.&lt;/p&gt;

&lt;p&gt;En plus de cela, il est assez difficile en une seule passe de rendu de pouvoir optimiser son algorithme pour faire moins de calcul.
Un exemple simple est l&amp;rsquo;utilisation d&amp;rsquo;un grand nombre de lumières n&amp;rsquo;émettant que dans un volume réduit de la scène.
Ce type de lumière affecte assez peu de pixels.
Avec un forward renderer, il n&amp;rsquo;y a que dans le fragment shader qu&amp;rsquo;on peut s&amp;rsquo;appercevoir qu&amp;rsquo;une lumière donnée n&amp;rsquo;affecte pas le fragment, c&amp;rsquo;est déjà trop tard.
En ayant accès à plus d&amp;rsquo;information sur la géométrie visible par la caméra, il est possible d&amp;rsquo;affecter rapidement des listes de lumières à des tiles de pixel et ainsi de passer moins de temps globalement dans le fragment shader.&lt;/p&gt;

&lt;p&gt;Le deferred rendering est un autre algorithme de rendu permettant de palier à ces problèmes.&lt;/p&gt;

&lt;h2 id=&#34;le-deferred-shading&#34;&gt;Le Deferred Shading&lt;/h2&gt;

&lt;p&gt;Le principe du deferred est de découpler le traitement de la géométrie (vertex buffer + rasterisation) du traitement des fragments (shading dans le fragment shader).&lt;/p&gt;

&lt;p&gt;Une première passe de rendu dessine donc tous les objets de la scène, mais plutot que de les illuminer dans le fragment shader, elle écrit les informations de chaque fragment dans des textures.
Ces informations sont celles utilisées pour le lighting: position, normale et texCoords du fragment, mais également paramètres de matériaux (ambiant, diffus, glossy et shininess).
Comme ces informations sont majoritairement de nature géométrique, l&amp;rsquo;ensemble des textures de sortie est généralement appelé &lt;strong&gt;GBuffer&lt;/strong&gt; et cette première passe de rendu s&amp;rsquo;appelle la &lt;strong&gt;Geometry Pass&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Une fois la première passe accomplie et le GBuffer remplit, on effectue la &lt;strong&gt;Shading Pass&lt;/strong&gt;, qui consiste à utiliser le GBuffer pour illuminer chaque pixel.
Au cours de cette passe, on dessiner simplement un quad couvrant l&amp;rsquo;écran, le vertex shader ne fait donc quasiment rien.
Au contraire, le fragment shader lit dans les textures du GBuffer les informations du pixel courant (qui ont été enregistré pendant la geometry pass) et calcule la couleur finale à partir de ces infos et des lumières de la scène.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;image ci-dessous montre en haut un rendu final, résultat de la Shading Pass appliquée au GBuffer donc les textures sont montrés en bas:
&lt;img src=&#34;https://Celeborn2BeAlive.github.io/opengl-avance/images/gbuffer_1.png&#34; alt=&#34;GBuffer&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A noter qu&amp;rsquo;il y énormément de manière de remplir un GBuffer en fonction des performances voulues.
Pour ces TPs, on se contentera d&amp;rsquo;écrire tous les informations dont on a besoin pour le lighting, sans chercher à optimiser.&lt;/p&gt;

&lt;h2 id=&#34;liens&#34;&gt;Liens&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342&#34;&gt;Explication des deux approches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html&#34;&gt;Tuto OpenGL Dev&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Pipeline de rendu</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/02-forward-shading/pipeline/</link>
      <pubDate>Thu, 29 Dec 2016 12:15:45 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/02-forward-shading/pipeline/</guid>
      <description>&lt;p&gt;Le &lt;a href=&#34;https://www.wikiwand.com/fr/Forward_Rendering&#34;&gt;&lt;strong&gt;forward shading&lt;/strong&gt;&lt;/a&gt; (ou &lt;strong&gt;forward rendering&lt;/strong&gt;) est le rendu &amp;ldquo;classique&amp;rdquo; OpenGL que vous avez normalement vu l&amp;rsquo;année dernière. Cette partie est donc une série d&amp;rsquo;exercices pour implémenter rapidement un forward renderer afin de se remettre tranquilement dans le bain.&lt;/p&gt;

&lt;p&gt;Pour chaque objet de la scène, un forward renderer fait passer la géométrie de l&amp;rsquo;objet dans un Vertex Shader afin de projeter les sommets à l&amp;rsquo;écran, la carte graphique rasterise les triangles projetés pour produire des fragments qui sont illuminés dans le fragment shader afin de calculer leur couleur.&lt;/p&gt;

&lt;p&gt;Cette approche à le mérite d&amp;rsquo;être simple mais introduit un coup supplémentaire lorsque beaucoup de fragments sont occultés: on paye le coup d&amp;rsquo;illumination de ces derniers alors qu&amp;rsquo;ils sont finalement discardés par le test de profondeur. Le TD suivant vous fera implémenter un &lt;strong&gt;deferred renderer&lt;/strong&gt;, qui palie à ce problème.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342&#34;&gt;Voir également cet article&lt;/a&gt; qui explique le principe des deux approches.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;objectif à la fin de ce premier TP est de pouvoir charger une scène 3D en OBJ constituée de modèles texturées, et pouvoir naviguer dedans en vue FPS.&lt;/p&gt;

&lt;p&gt;Commencez par dupliquer le repertoire &lt;em&gt;apps/template&lt;/em&gt; et renommez le &lt;em&gt;forward-renderer&lt;/em&gt;. Vous partirez du code de ce dossier. N&amp;rsquo;oubliez pas de &lt;strong&gt;relancer CMake&lt;/strong&gt; pour prendre en compte la nouvelle application. Il faudra églament relancer CMake à chaque ajout de fichier source ou shader. Pour faire cela rapidement, se placer dans le dossier de build et lancer simplement la commande &lt;strong&gt;&amp;ldquo;cmake .&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Les instructions de ce premier TP seront concises car ce sont des exercices de rappel.
Attachez vous à utiliser des fonctions de l&amp;rsquo;extension direct_state_access afin de moderniser votre code.
N&amp;rsquo;hésitez pas à prendre exemple sur les applications déjà présente dans le template, et à vous aidez &lt;a href=&#34;https://Celeborn2BeAlive.github.io/opengl-avance/01-introduction/liens/&#34;&gt;des liens&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/01-introduction/introduction/</link>
      <pubDate>Thu, 29 Dec 2016 11:34:23 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/01-introduction/introduction/</guid>
      <description>

&lt;h2 id=&#34;objectifs&#34;&gt;Objectifs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Approfondir les connaissances en OpenGL Moderne&lt;/li&gt;
&lt;li&gt;Premières implémentations de techniques avancées&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Projet&lt;/strong&gt;: implémentation d&amp;rsquo;articles de recherche&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;prérequis&#34;&gt;Prérequis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bonne connaissance du &lt;a href=&#34;https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview&#34;&gt;pipeline de rendu OpenGL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Maitrise des &lt;a href=&#34;http://laurentnoel.fr/index.php?section=teaching&amp;amp;teaching=opengl&amp;amp;teaching_section=tds&#34;&gt;TDs des années précédentes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quelle-version-d-opengl&#34;&gt;Quelle version d&amp;rsquo;OpenGL ?&lt;/h2&gt;

&lt;p&gt;La version installée sur les machines de la fac est la 4.4, nous prendrons donc cette version comme base.
En plus de cela, le template de code que j&amp;rsquo;ai préparé charge l&amp;rsquo;extension &lt;strong&gt;GL_ARB_direct_state_access&lt;/strong&gt;, dont les fonctions sont passées en OpenGL Core dans la version 4.5.&lt;/p&gt;

&lt;h2 id=&#34;direct-state-access&#34;&gt;Direct State Access&lt;/h2&gt;

&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Cette extension n&amp;rsquo;est pas disponible sur toutes les cartes graphiques. En particulier les machines de la FAC n&amp;rsquo;en sont pas equipées entièrement (il y a l&amp;rsquo;extension &lt;strong&gt;GL_EXT_direct_state_access&lt;/strong&gt; qui n&amp;rsquo;est que partielle). Si vous n&amp;rsquo;y avez pas accès, ne l&amp;rsquo;utilisez pas: cette extension ne fournit que des facilités de programmation, pas de fonctionnalité en plus.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Cette extension est très pratique car elle permet d&amp;rsquo;éviter de binder les objets OpenGL pour les manipuler (on passe aux fonctions directement l&amp;rsquo;identifiant de l&amp;rsquo;objet), et donc d&amp;rsquo;éviter les erreurs liées au mécanisme de binding. Je vous conseille donc de l&amp;rsquo;utiliser autant que possible.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.opengl.org/registry/specs/ARB/direct_state_access.txt&#34;&gt;Lien vers le document de référence&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Voici des exemples de code en version OpenGL 3 classique et en version Direct State Access (directement tiré du document):&lt;/p&gt;

&lt;h4 id=&#34;example-1-creating-a-buffer-object-without-polluting-the-opengl-states&#34;&gt;Example 1: Creating a buffer object without polluting the OpenGL states&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Bind to Create
GLuint CreateBuffer()
{
  // Save the previous bound buffer
  GLuint restoreBuffer = 0;
  glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &amp;amp;restoreBuffer);

  // Reserve the buffer name and create the buffer object
  uint buffer = 0;
  glGenBuffers(1, &amp;amp;buffer);
  glBindBuffer(GL_ARRAY_BUFFER, buffer);

  // Restaure the previous bound buffer to avoid polluting
  // the rendering states
  glBindBuffer(GL_ARRAY_BUFFER, restoreBuffer);

  return buffer;
}

// Direct State Access
GLuint CreateBuffer()
{
  GLuint buffer = 0;
  glCreateBuffer(1, &amp;amp;buffer);

  return buffer;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-2-creating-a-vertex-array-object-without-polluting-the-opengl-states&#34;&gt;Example 2: Creating a vertex array object without polluting the OpenGL states&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// OpenGL 3.0 Bind to Create for vertex array object
GLuint CreateVertexArray(GLuint BufferName[])
{
  // Save the previous bound vertex array and array buffer
  GLuint restoreVertexArray = 0;
  glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &amp;amp;restoreVertexArray);
  GLuint restoreBuffer = 0;
  glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &amp;amp;restoreBuffer);

  glGenVertexArrays(1, &amp;amp;VertexArrayName);
  glBindVertexArray(VertexArrayName);
    glEnableVertexAttribArray(semantic::attr::POSITION);
    glEnableVertexAttribArray(semantic::attr::TEXCOORD);

    glBindBuffer(GL_ARRAY_BUFFER, BufferName[buffer::VERTEX]);
    glVertexAttribPointer(semantic::attr::POSITION, 2, GL_FLOAT, GL_FALSE, sizeof(glf::vertex_v2fv2f), BUFFER_OFFSET(0));
    glVertexAttribPointer(semantic::attr::TEXCOORD, 2, GL_FLOAT, GL_FALSE, sizeof(glf::vertex_v2fv2f), BUFFER_OFFSET(sizeof(glm::vec2)));

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, BufferName[buffer::ELEMENT]);

  // The GL_ARRAY_BUFFER_BINDING is a context state, not a vertex array state.
  glBindBuffer(GL_ARRAY_BUFFER, restoreBuffer);
  glBindVertexArray(restoreVertexArray);

  return vertexArrayName;
}

// OpenGL 4.3 Bind to Create for vertex array object
GLuint CreateVertexArray(GLuint BufferName[])
{
  // Save the previous bound vertex array
  GLuint restoreVertexArray = 0;
  glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &amp;amp;restoreVertexArray);

  GLuint vertexArrayName = 0;
  glGenVertexArrays(1, &amp;amp;vertexArrayName);
  glBindVertexArray(VertexArrayName);
    glEnableVertexAttribArray(semantic::attr::POSITION);
    glEnableVertexAttribArray(semantic::attr::TEXCOORD);

    glVertexAttribBinding(semantic::attr::POSITION, 0);
    glVertexAttribFormat(semantic::attr::POSITION, 2, GL_FLOAT, GL_FALSE, 0);

    glVertexAttribBinding(semantic::attr::TEXCOORD, 0);
    glVertexAttribFormat(semantic::attr::TEXCOORD, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, BufferName[buffer::ELEMENT]);
    glBindVertexBuffer(0, BufferName[buffer::VERTEX], 0, 0);
  glBindVertexArray(restoreVertexArray);

  return vertexArrayName;
}

// Direct State Access
GLuint CreateVertexArray(GLuint BufferName[])
{
  GLuint vertexArrayName = 0;
  glCreateVertexArrays(1, &amp;amp;vertexArrayName);

  glEnableVertexAttribArray(VertexArrayName, semantic::attr::POSITION);
  glEnableVertexAttribArray(VertexArrayName, semantic::attr::TEXCOORD);

  glVertexArrayAttribBinding(VertexArrayName, semantic::attr::POSITION, 0);
  glVertexArrayAttribFormat(VertexArrayName, semantic::attr::POSITION, 2, GL_FLOAT, GL_FALSE, 0);

  glVertexArrayAttribBinding(VertexArrayName, semantic::attr::TEXCOORD, 0);
  glVertexArrayAttribFormat(VertexArrayName, semantic::attr::TEXCOORD, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2);

  glVertexArrayElementBuffer(VertexArrayName, BufferName[buffer::ELEMENT]);
  glVertexArrayVertexBuffer(VertexArrayName, 0, BufferName[buffer::VERTEX], 0, 0);

  return vertexArrayName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;example-3-querying-the-bound-texture-to-a-texture-image-unit-for-debugging&#34;&gt;Example 3: Querying the bound texture to a texture image unit for debugging&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Select to query
// We need the &amp;lt;target&amp;gt; or we need to loop over all the possible targets
GLuint GetBoundTexture(GLenum target, GLuint unit)
{
  GLuint restore = 0;
  glGetIntegerv(GL_ACTIVE_TEXTURE, &amp;amp;restore);

  glActiveTexture(unit);

  GLuint name = 0;
  glGetIntegerv(target, &amp;amp;name);

  glActiveTexture(restore);
}

// Direct State Access
// target_binding is e.g. GL_TEXTURE_BINDING_2D for the 2D texture
GLuint GetBoundTexture(GLenum target_binding, GLuint unit)
{
  GLuint name = 0;
  glGetIntegeri_v(target_binding, unit, &amp;amp;name);
  return name;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>OpenGL Extensions</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/06-course/opengl-extensions/</link>
      <pubDate>Fri, 20 Jan 2017 00:05:53 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/06-course/opengl-extensions/</guid>
      <description>

&lt;p&gt;Le méchanisme d&amp;rsquo;extensions OpenGL permet aux constructeurs de carte graphique d&amp;rsquo;ajouter à l&amp;rsquo;API des fonctionnalités avancées qui ne sont pas encore présentes dans le Core profile.&lt;/p&gt;

&lt;p&gt;Il est assez standard d&amp;rsquo;utiliser des extensions OpenGL et d&amp;rsquo;adapter son moteur en fonction des extensions disponibles sur la carte graphique de l&amp;rsquo;utilisateur.&lt;/p&gt;

&lt;p&gt;Le nom des extensions suit une nomenclature assez précises. Il y a 3 types d&amp;rsquo;extensions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Propriétaires: Spécifiques à un seul constructeur. Par exemple les extensions préfixées par GL_NV sont spécifiques aux GPU de NVidia.&lt;/li&gt;
&lt;li&gt;Génériques: Généralement implémentées par un grand nombre de constructeurs. Préfixées par GL_EXT&lt;/li&gt;
&lt;li&gt;ARB: Extensions génériques approuvées par l&amp;rsquo;&lt;a href=&#34;https://www.opengl.org/archives/about/arb/&#34;&gt;OpenGL ARB&lt;/a&gt;, destinées à entrer dans le Core profile d&amp;rsquo;une future version d&amp;rsquo;OpenGL.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Les extensions sont détaillées dans un fichier texte dedié assez difficile à lire (exemple: &lt;a href=&#34;https://www.opengl.org/registry/specs/ARB/vertex_array_object.txt&#34;&gt;https://www.opengl.org/registry/specs/ARB/vertex_array_object.txt&lt;/a&gt;) car il mentionne des additions, suppressions ou modifications dans la spécification générale d&amp;rsquo;OpenGL.&lt;/p&gt;

&lt;p&gt;Plus d&amp;rsquo;infos sur le Wiki: &lt;a href=&#34;https://www.khronos.org/opengl/wiki/OpenGL_Extension&#34;&gt;https://www.khronos.org/opengl/wiki/OpenGL_Extension&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pour savoir si une extension OpenGL est proposée par votre driver, vous pouvez utiliser la commande *glxinfo sous Linux (&lt;em&gt;nvidia-config &amp;ndash;glxinfo&lt;/em&gt; sous certains système) et piper le résultat dans un grep du nom de l&amp;rsquo;extension recherchée. Sous windows vous pouvez passer par un utilitaire tel que &lt;a href=&#34;http://realtech-vr.com/admin/glview&#34;&gt;GLview&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Quelques extensions très interessantes:&lt;/p&gt;

&lt;h2 id=&#34;direct-state-access&#34;&gt;Direct State Access&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;extension Direct State Access (DSA) (&lt;a href=&#34;https://www.opengl.org/registry/specs/EXT/direct_state_access.txt&#34;&gt;GL_EXT_direct_state_access&lt;/a&gt;, puis &lt;a href=&#34;https://www.opengl.org/registry/specs/ARB/direct_state_access.txt&#34;&gt;GL_ARB_direct_state_access&lt;/a&gt;, puis introduite en Core 4.5) propose une nouvelle manière de modifier/accéder aux objets OpenGL, sans avoir à les binder.&lt;/p&gt;

&lt;p&gt;Cela permet d&amp;rsquo;éviter de se préoccuper de l&amp;rsquo;état global du contexte OpenGL lorsque l&amp;rsquo;on veut manipuler les objets OpenGL et ainsi d&amp;rsquo;éviter un grand nombre d&amp;rsquo;erreurs de programmation.&lt;/p&gt;

&lt;h2 id=&#34;debug-output&#34;&gt;Debug Output&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;extension Debug Output (&lt;a href=&#34;https://www.opengl.org/registry/specs/ARB/debug_output.txt&#34;&gt;GL_ARB_debug_output&lt;/a&gt;, puis introduite en Core 4.3) à fait beaucoup de bien aux développeurs OpenGL puisqu&amp;rsquo;elle fournit un méchanisme de messages d&amp;rsquo;erreurs bien plus efficace que l&amp;rsquo;ignoble fonction &lt;em&gt;glGetError&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;idée est de donner une fonction de callback à OpenGL qui sera appelée par l&amp;rsquo;implémentation dès qu&amp;rsquo;une erreur est rencontrée. Il est de plus possible de filtrer de manière assez fine les erreurs/warning à ignorer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pipeline de Rendu</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/06-course/gpu-pipeline/</link>
      <pubDate>Thu, 19 Jan 2017 23:57:26 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/06-course/gpu-pipeline/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview&#34;&gt;Cette page du wiki&lt;/a&gt; décrit l&amp;rsquo;ensemble du pipeline de rendu OpenGL.&lt;/p&gt;

&lt;p&gt;Le schéma suivant illustre ce pipeline (&lt;a href=&#34;http://www.lighthouse3d.com/2011/03/opengl-4-1-pipeline/&#34;&gt;source&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.lighthouse3d.com/wp-content/uploads/2011/03/pipeline4.png&#34; alt=&#34;OpenGL Pipeline&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGL44PipelineMap.pdf&#34;&gt;Et ce schéma entre dans le détail de chaque étape&lt;/a&gt; (un joli poster à accrocher au mur :p)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Directional SM - Création</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map-creation/</link>
      <pubDate>Thu, 19 Jan 2017 23:22:14 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map-creation/</guid>
      <description>&lt;p&gt;todo.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gamma correction</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/05-post-processing/gamma-correction/</link>
      <pubDate>Thu, 29 Dec 2016 12:36:04 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/05-post-processing/gamma-correction/</guid>
      <description>&lt;p&gt;Lorem Ipsum&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Geometry pass</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/geometry-pass/</link>
      <pubDate>Thu, 29 Dec 2016 12:27:23 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/03-deferred-shading/geometry-pass/</guid>
      <description>

&lt;p&gt;Comme indiqué en introduction, la première passe de rendu est la Geometry Pass, dont l&amp;rsquo;objectif est de &amp;ldquo;dessiner&amp;rdquo; dans un GBuffer les informations concernant les objets visible à l&amp;rsquo;écran.&lt;/p&gt;

&lt;p&gt;Pour cela, il va falloir créer les textures OpenGL destinées à contenir ces informations, et les attacher à un &lt;strong&gt;framebuffer object&lt;/strong&gt;, qui va permettre d&amp;rsquo;écrire dans ces textures plutot qu&amp;rsquo;a l&amp;rsquo;écran.&lt;/p&gt;

&lt;p&gt;Pour ces TPs, dupliquez l&amp;rsquo;app de l&amp;rsquo;exercice du foward renderer afin d&amp;rsquo;avoir une scene chargée et stockée sur GPU pour être rendue.
Nommez la nouvelle app &amp;ldquo;deferred-renderer&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;shaders&#34;&gt;Shaders&lt;/h2&gt;

&lt;p&gt;Nous allons commencer par les shaders car c&amp;rsquo;est le plus simple.
Renommez les shaders &lt;em&gt;forward.vs.glsl&lt;/em&gt; et &lt;em&gt;forward.fs.glsl&lt;/em&gt; en &lt;em&gt;geometryPass.vs.glsl&lt;/em&gt; et &lt;em&gt;geometryPass.fs.glsl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Il faut ensuite modifier le fragment shader (plus exactement le simplifier).&lt;/p&gt;

&lt;p&gt;Tout d&amp;rsquo;abors modifier les sorties. On avait:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;out vec3 fColor;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a remplacer par:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;layout(location = 0) out vec3 fPosition;
layout(location = 1) out vec3 fNormal;
layout(location = 2) out vec3 fAmbient;
layout(location = 3) out vec3 fDiffuse;
layout(location = 4) out vec4 fGlossyShininess;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On va donc écrire dans 5 textures en tout.&lt;/p&gt;

&lt;p&gt;Dans le main du shader, remplacez tout le code d&amp;rsquo;illumination par des écritures dans les variables de sortie. Ne pas oublier de normaliser &lt;em&gt;vViewSpaceNormal&lt;/em&gt; avant de l&amp;rsquo;écrire dans &lt;em&gt;fNormal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A noter que l&amp;rsquo;on écrit pas les texCoords en sortie car on ne les utilise que pour lire les coefficients ambiant, diffus et glossy des textures de l&amp;rsquo;objet en cours de rendu. Les texCoords ne sont donc pas necessaire à la Shading Pass puisqu&amp;rsquo;on écrit directement ces coefficients dans des textures du GBuffer.&lt;/p&gt;

&lt;p&gt;Les variables de sortie de matériaux doivent stocker la multiplication du coefficient associé avec la valeur lue dans la texture. Par exemple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform vec3 uKd;
uniform sampler2D uKdSampler;

[...]

// Dans le main:
vec3 kd = uKd * vec3(texture(uKdSampler, vTexCoords));
fDiffuse = kd;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enfin, il faut packer la shininess dans le canal alpha de la variable de sortie &lt;em&gt;fGlossyShininess&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Dans le code de Application, chargez ces shaders pour tester leur compilation.&lt;/p&gt;

&lt;h2 id=&#34;textures-du-gbuffer&#34;&gt;Textures du GBuffer&lt;/h2&gt;

&lt;p&gt;Dans la classe Application, déclarez un tableau de &lt;em&gt;GLuint&lt;/em&gt; pour stocker les texture objects, ainsi que l&amp;rsquo;enum suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum GBufferTextureType
{
    GPosition = 0,
    GNormal,
    GAmbient,
    GDiffuse,
    GGlossyShininess,
    GDepth, // On doit créer une texture de depth mais on écrit pas directement dedans dans le FS. OpenGL le fait pour nous (et l&#39;utilise).
    GBufferTextureCount
};
GLuint m_GBufferTextures[GBufferTextureCount];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans le constructeur, créer et initialiser ces textures avec comme dimension la taille de la fenêtre.&lt;/p&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;Vous pouvez créer toutes les textures en un seul appel à glGenTextures (ou glCreateTextures en DSA) car nos identifiants sont stockés dans un tableau. Il suffit de passer à la fonction le nombre de textures à créer.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Le format à passer à &lt;em&gt;glTexStorage2D&lt;/em&gt; dépend du type de texture, vous pouvez utiliser le tableau suivant, en correspondance avec l&amp;rsquo;enum:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const GLenum m_GBufferTextureFormat[GBufferTextureCount] = { GL_RGB32F, GL_RGB32F, GL_RGB32F, GL_RGB32F, GL_RGBA32F, GL_DEPTH_COMPONENT32F };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il est inutile de remplir les textures avec &lt;em&gt;glTexSubImage2D&lt;/em&gt; car elles sont destinées à être remplies par le fragment shader.&lt;/p&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenTextures&lt;/td&gt;
&lt;td&gt;glCreateTextures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindTexture(GL_TEXTURE_2D, texID)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glTexStorage2D&lt;/td&gt;
&lt;td&gt;glTextureStorage2D&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;framebuffer-object&#34;&gt;Framebuffer object&lt;/h2&gt;

&lt;p&gt;Déclarez une variable &lt;em&gt;GLuint m_FBO&lt;/em&gt; dans la classe Application.&lt;/p&gt;

&lt;p&gt;Dans le constructeur, après création des texture objects, créez le FBO (&lt;em&gt;glGenFramebuffers&lt;/em&gt;) et bindez le sur la cible &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Il faut ensuite attacher toutes nos textures au FBO en utilisant la fonction &lt;em&gt;glFramebufferTexture2D&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;glFramebufferTexture2D( GLenum target,
    GLenum attachment,
    GLenum textarget,
    GLuint texture,
    GLint level);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La target est la cible sur laquelle est bindée de FBO (&lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;attachment est un point d&amp;rsquo;attache de la forme &lt;em&gt;GL_COLOR_ATTACHMENT0 + i&lt;/em&gt;, ou &lt;em&gt;i&lt;/em&gt; est l&amp;rsquo;index de la texture dans son tableau (de &lt;em&gt;GPosition&lt;/em&gt; à &lt;em&gt;GGlossyShininess&lt;/em&gt;).
Pour la texture de profondeur (&lt;em&gt;GDepth&lt;/em&gt;), elle doit être attachée sur le point &lt;em&gt;GL_DEPTH_ATTACHMENT&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Dans notre cas, &lt;em&gt;textarget&lt;/em&gt; doit être mis à &lt;em&gt;GL_TEXTURE_2D&lt;/em&gt; car toutes nos textures sont 2D (on pourrait aussi faire le rendu dans des layers de textures 3D, il faudrait alors changer ce paramètre).&lt;/p&gt;

&lt;p&gt;Enfin, &lt;em&gt;level&lt;/em&gt; doit être mis à 0 (c&amp;rsquo;est le niveau de mipmap dans lequel dessiner).&lt;/p&gt;

&lt;p&gt;Une fois les textures attachées, il faut indiquer à OpenGL une association &amp;ldquo;sortie du fragment shader&amp;rdquo; vers texture.
Comme vous le verrez au prochain exercice, le fragment shader peut avoir plusieurs sorties indicées avec des &lt;em&gt;layout(location = i)&lt;/em&gt; (de la meme manière que les entrée du vertex shader).
Il faut dire à OpenGL comment les locations doivent être connectées aux textures du FBO.&lt;/p&gt;

&lt;p&gt;Cela passe par la fonction &lt;em&gt;glDrawBuffers&lt;/em&gt;, qui prend le nombre de sorties du fragment shader et un tableau de &lt;em&gt;GL_COLOR_ATTACHMENTi&lt;/em&gt; afin de faire la liaison. Nous allons faire assez simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;GLenum drawBuffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4 };
glDrawBuffers(6, drawBuffers);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ici on va envoyer la sortie &lt;em&gt;i&lt;/em&gt; du fragment shader vers l&amp;rsquo;attachment &lt;em&gt;GL_COLOR_ATTACHMENTi&lt;/em&gt; du FBO.
C&amp;rsquo;est ce qui parait le plus logique mais, si on voulait, on pourrait tout à fait envoyer la sortie 3 du fragment shader vers la texture attachée sur GL_COLOR_ATTACHMENT0, par exemple.&lt;/p&gt;

&lt;p&gt;Utilisez ensuite la fonction &lt;em&gt;glCheckFramebufferStatus&lt;/em&gt; afin de vérifier si le framebuffer créé est correct (si ce n&amp;rsquo;est pas le cas, bon debug !).&lt;/p&gt;

&lt;p&gt;Enfin débindez le framebuffer de la cible &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenFramebuffers&lt;/td&gt;
&lt;td&gt;glCreateFramebuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glFramebufferTexture2D&lt;/td&gt;
&lt;td&gt;glNamedFramebufferTexture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glDrawBuffers&lt;/td&gt;
&lt;td&gt;glNamedFramebufferDrawBuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glCheckFramebufferStatus&lt;/td&gt;
&lt;td&gt;glCheckNamedFramebufferStatus&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;boucle-de-rendu&#34;&gt;Boucle de rendu&lt;/h2&gt;

&lt;p&gt;Au rendu assez peu de chose à changer.&lt;/p&gt;

&lt;p&gt;Avant de dessiner, binder le framebuffer sur la cible &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt;. Cela va indiquer à OpenGL que le fragment shader va écrire dans les textures attachées au FBO.&lt;/p&gt;

&lt;p&gt;Il faut également faire un &lt;em&gt;.use()&lt;/em&gt; sur le programme correspondant au aux &lt;em&gt;geometryPass.glsl&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Après le dessin de la scène, débindez le FBO. Voila.&lt;/p&gt;

&lt;p&gt;Pour tester que tout fonctionne bien, on peut blitter les textures du GBuffer à l&amp;rsquo;écran.&lt;/p&gt;

&lt;p&gt;Après le débind du FBO, rebindez le, cette fois ci sur la cible &lt;em&gt;GL_READ_FRAMEBUFFER&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Utilisez ensuite la fonction &lt;em&gt;glReadBuffer&lt;/em&gt;, qui prend en paramètre un &lt;em&gt;GL_COLOR_ATTACHMENT0 + i&lt;/em&gt;, correspondant à la texture du GBuffer que vous voulez afficher. Vous pouvez par example afficher la texture de normals en passant &lt;em&gt;GL_COLOR_ATTACHMENT0 + GNormal&lt;/em&gt;. Faites ensuite en sorte de pouvoir choisir la texture à afficher via la GUI (avec des boutons radio, &lt;em&gt;ImgGui::RadioButton&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Puis utilisez la fonction &lt;em&gt;glBlitFramebuffer&lt;/em&gt; qui permet de &amp;ldquo;copier-coller&amp;rdquo; (avec filtre) une portion du FBO bindé sur &lt;em&gt;GL_READ_FRAMEBUFFER&lt;/em&gt; vers le FBO bindé sur &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt; (c&amp;rsquo;est à dire l&amp;rsquo;écran, lorsque rien n&amp;rsquo;est bindé dessus).&lt;/p&gt;

&lt;p&gt;Finalement, débindez le FBO de &lt;em&gt;GL_READ_FRAMEBUFFER&lt;/em&gt;. A noter qu&amp;rsquo;en DSA il n&amp;rsquo;y a rien à binder pour l&amp;rsquo;étape du blit (il faut quand même binder sur &lt;em&gt;GL_DRAW_FRAMEBUFFER&lt;/em&gt; avant de dessiner la scène).&lt;/p&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glReadBuffer&lt;/td&gt;
&lt;td&gt;glNamedFramebufferReadBuffer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBlitFramebuffer&lt;/td&gt;
&lt;td&gt;glBlitNamedFramebuffer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Geometrie</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/02-forward-shading/geometrie/</link>
      <pubDate>Thu, 29 Dec 2016 12:18:05 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/02-forward-shading/geometrie/</guid>
      <description>&lt;div class=&#34;notices warning&#34; &gt;&lt;p&gt;Vous aurez un écran noir jusqu&amp;rsquo;a la fin de la première partie de l&amp;rsquo;exercice &lt;a href=&#34;https://Celeborn2BeAlive.github.io/opengl-avance/02-forward-shading/transformations/&#34;&gt;Transformations&lt;/a&gt;: OpenGL demande généralement beaucoup de code d&amp;rsquo;initialisation avant de pouvoir afficher quelque chose.&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;Vous allez commencer par dessiner des cubes et spheres en 3D. La lib &lt;em&gt;glmlv&lt;/em&gt; contient deux fonctions makeCube() et makeSphere() (simple_geometry.hpp) permettant de construire des tableaux de sommets et indices pour ces deux forme simple.&lt;/p&gt;

&lt;p&gt;A l&amp;rsquo;initialisation (constructeur de Application):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Utiliser ces fonctions pour construire la géométrie d&amp;rsquo;une sphere et d&amp;rsquo;un cube.&lt;/li&gt;
&lt;li&gt;Pour chacune de ces formes, construire un VBO, un VAO et un IBO et les remplir correctement.&lt;/li&gt;
&lt;li&gt;Activer le depth test&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dans la boucle de rendu (Application::run):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adapter l&amp;rsquo;appel à glClear pour aussi nettoyer le depth buffer&lt;/li&gt;
&lt;li&gt;Pour chaque objet: binder le VAO, dessiner l&amp;rsquo;objet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fonctions OpenGL à utiliser à l&amp;rsquo;initialisation:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenBuffers&lt;/td&gt;
&lt;td&gt;glCreateBuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glGenVertexArrays&lt;/td&gt;
&lt;td&gt;glCreateVertexArrays&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindBuffer(GL_ARRAY_BUFFER, vboID)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBufferStorage&lt;/td&gt;
&lt;td&gt;glNamedBufferStorage&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;glVertexArrayVertexBuffer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;glVertexArrayAttribBinding&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glEnableVertexAttribArray&lt;/td&gt;
&lt;td&gt;glEnableVertexArrayAttrib&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glVertexAttribPointer&lt;/td&gt;
&lt;td&gt;glVertexArrayAttribFormat&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboID)&lt;/td&gt;
&lt;td&gt;glVertexArrayElementBuffer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glEnable(GL_DEPTH_TEST)&lt;/td&gt;
&lt;td&gt;glEnable(GL_DEPTH_TEST)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Fonctions OpenGL à utiliser au rendu:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;glBindVertexArray&lt;/li&gt;
&lt;li&gt;glDrawElements (le nombre de sommets à dessiner est le nombre d&amp;rsquo;elements dans l&amp;rsquo;indexBuffer)&lt;/li&gt;
&lt;li&gt;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Voir le programme &lt;em&gt;quad&lt;/em&gt; du template pour un exemple simple en 2D.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;A l&amp;rsquo;initialisation du VAO, il faut utiliser pour attribut de vertex (position, normal, texCoords) un entier correspondant à la location de cet attribut dans le vertex shader.
Le VS n&amp;rsquo;est pas encore écrit mais on peut déjà choisir les location (le plus simple: position en 0, normal en 1 et texCoords en 2).&lt;/p&gt;
&lt;/div&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Code template</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/01-introduction/code-template/</link>
      <pubDate>Thu, 29 Dec 2016 11:36:02 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/01-introduction/code-template/</guid>
      <description>

&lt;h2 id=&#34;téléchargement&#34;&gt;Téléchargement&lt;/h2&gt;

&lt;p&gt;Clonez, forkez sur votre compte Github ou téléchargez le &lt;a href=&#34;https://github.com/Celeborn2BeAlive/opengl-avance&#34;&gt;repository sur github&lt;/a&gt; (fork de préférence, plus facile de partager le code avec moi ensuite)&lt;/p&gt;

&lt;h2 id=&#34;branches-du-repo&#34;&gt;Branches du repo&lt;/h2&gt;

&lt;p&gt;Principales:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;master &lt;em&gt;Code de base + apps d&amp;rsquo;exemple en OpenGL 3&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;master-direct-state-access &lt;em&gt;Code de base + apps d&amp;rsquo;exemple en OpenGL 4.5 (avec DSA)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Corrections:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cheat &lt;em&gt;Correction des TDs en OpenGL 3&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;cheat-direct-state-access &lt;em&gt;Correction des TDs en OpenGL OpenGL 4.5 (avec DSA)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;compilation&#34;&gt;Compilation&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Avec CMake&lt;/li&gt;
&lt;li&gt;Support de GCC 5+ (sans boost), GCC 4.9.2 (boost requis) et Visual Studio 2015 (sans boost)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;

&lt;p&gt;En console:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Créer un repertoire &lt;em&gt;opengl-avance-build&lt;/em&gt; à coté du repertoire &lt;em&gt;opengl-avance&lt;/em&gt; (correspondant au clone du repo)&lt;/li&gt;
&lt;li&gt;Se placer dans &lt;em&gt;opengl-avance-build&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Sur un PC ou GCC 5+ est installé, taper la commande &lt;strong&gt;cmake ../opengl-avance&lt;/strong&gt;. Si uniquement GCC 4.9.2 est disponible (machines de la FAC), taper la commande &lt;strong&gt;cmake -DGLMLV_USE_BOOST_FILESYSTEM=ON ../opengl-avance&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Compiler avec &lt;strong&gt;make -j&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Les executables sont compilés dans le repertoire &lt;em&gt;bin&lt;/em&gt; du dossier de build&lt;/p&gt;

&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Télécharger et installer &lt;a href=&#34;https://cmake.org/download/&#34;&gt;CMake GUI&lt;/a&gt; (Windows win64-x64 Installer ou Windows win32-x86 Installer selon votre CPU) et &lt;a href=&#34;https://www.visualstudio.com/fr/vs/community/&#34;&gt;Visual Studio Community Edition 2015&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Créer un repertoire &lt;em&gt;opengl-avance-build&lt;/em&gt; à coté du repertoire &lt;em&gt;opengl-avance&lt;/em&gt; (correspondant au clone du repo)&lt;/li&gt;
&lt;li&gt;Lancer CMake GUI, choisir comme repertoire source le clone du repo et comme repertoire de build le dossier que vous avez créé&lt;/li&gt;
&lt;li&gt;Cliquer sur &lt;strong&gt;Configure&lt;/strong&gt; et choisir comme generateur: &lt;em&gt;Visual Studio 14 2015 Win64&lt;/em&gt; pour un CPU 64-bits, &lt;em&gt;Visual Studio 14 2015&lt;/em&gt; pour un CPU 32-bits (ça existe encore ?)&lt;/li&gt;
&lt;li&gt;Cliquer sur &lt;strong&gt;Generate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Ouvrir la solution Visual Studio &lt;em&gt;opengl.sln&lt;/em&gt; qui a été créée par CMake dans le repertoire de build&lt;/li&gt;
&lt;li&gt;Dans le panel &lt;em&gt;Explorateur de solutions&lt;/em&gt;, choisir le projet &lt;em&gt;template&lt;/em&gt; comme projet de démarage (clic droit dessus, puis trouver l&amp;rsquo;option)&lt;/li&gt;
&lt;li&gt;Menu &lt;em&gt;Générer&lt;/em&gt; -&amp;gt; &lt;em&gt;Générer la solution&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Lancer l&amp;rsquo;application avec F5 (debug) ou Ctrl+F5 (non debug)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Les executables sont compilés dans les repertoire &lt;em&gt;bin/Debug&lt;/em&gt; et &lt;em&gt;bin/Release&lt;/em&gt; selon la configuration.&lt;/p&gt;

&lt;p&gt;Il est possible de compiler le projet &lt;em&gt;INSTALL&lt;/em&gt; de la solution avec que les executables compilés soit recopiés dans un repertoire d&amp;rsquo;installation. Par défault ce repertoire est &lt;em&gt;C:/Program Files/opengl&lt;/em&gt; mais il est possible de le changer depuis CMake GUI en recherchant la variable &lt;em&gt;CMAKE_INSTALL_PREFIX&lt;/em&gt; et en la modifiant.&lt;/p&gt;

&lt;h2 id=&#34;arborescence&#34;&gt;Arborescence&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;apps &lt;em&gt;Contient le code des executables à compiler&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;cmake &lt;em&gt;Contient des modules cmake&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;lib &lt;em&gt;Contient le code partagé entre les executables&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;third-party &lt;em&gt;Contient des bibliothèques externes&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chaque sous-repertoire de &lt;em&gt;apps&lt;/em&gt; est compilé en tant qu&amp;rsquo;application indépendant. Ainsi le code du repertoire &lt;em&gt;apps/template&lt;/em&gt; sera compilé en un executable &lt;em&gt;template&lt;/em&gt; (Linux) ou &lt;em&gt;template.exe&lt;/em&gt; (Windows), et le code du repertoire &lt;em&gt;apps/triangle&lt;/em&gt; sera compilé en un executable &lt;em&gt;triangle&lt;/em&gt; (Linux) ou &lt;em&gt;triangle.exe&lt;/em&gt; (Windows).&lt;/p&gt;

&lt;p&gt;Le répertoire &lt;em&gt;lib&lt;/em&gt; est destiné à contenir du code d&amp;rsquo;une lib (nommée &lt;em&gt;glmlv&lt;/em&gt;) partagée entre les executables.&lt;/p&gt;

&lt;p&gt;Afin de garder un code clair, je vous conseille de créer une application différente par theme de TP. Il faudra également créer une application pour le projet.&lt;/p&gt;

&lt;h2 id=&#34;shaders&#34;&gt;Shaders&lt;/h2&gt;

&lt;p&gt;Concernant les shaders GLSL, le processus de compilation se charge de les copier à coté des executables afin qu&amp;rsquo;il soient facilement accessible (de manière relative) par ces derniers. Leur extension doit être &amp;ldquo;.glsl&amp;rdquo; afin qu&amp;rsquo;ils soient reconnu par le CMakeLists.txt, et ils doivent être placés dans un sous repertoire &lt;em&gt;shaders&lt;/em&gt; de l&amp;rsquo;application qui les utilise. Par convention, on suffixera &amp;ldquo;.vs.glsl&amp;rdquo; les vertex shader, &amp;ldquo;.fs.glsl&amp;rdquo; les fragments shaders, &amp;ldquo;.gs.glsl&amp;rdquo; les geometry shaders et &amp;ldquo;.cs.glsl&amp;rdquo; les compute shaders.&lt;/p&gt;

&lt;p&gt;La lib &lt;em&gt;glmlv&lt;/em&gt; peut également contenir des shaders partagés entre les applications, en les plaçant dans le repertoire &lt;em&gt;lib/shaders&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Par exemple, supposons l&amp;rsquo;arborescence suivante pour les shaders de &lt;em&gt;apps&lt;/em&gt; et &lt;em&gt;libs&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apps

&lt;ul&gt;
&lt;li&gt;triangle

&lt;ul&gt;
&lt;li&gt;shaders

&lt;ul&gt;
&lt;li&gt;triangle.vs.glsl&lt;/li&gt;
&lt;li&gt;triangle.fs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;smab

&lt;ul&gt;
&lt;li&gt;shaders

&lt;ul&gt;
&lt;li&gt;shadow_mapping

&lt;ul&gt;
&lt;li&gt;sm.vs.glsl&lt;/li&gt;
&lt;li&gt;sm.fs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;deferred

&lt;ul&gt;
&lt;li&gt;gbuffer.vs.glsl&lt;/li&gt;
&lt;li&gt;gbuffer.fs.glsl&lt;/li&gt;
&lt;li&gt;shading.vs.glsl&lt;/li&gt;
&lt;li&gt;shading.fs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;lib

&lt;ul&gt;
&lt;li&gt;shaders

&lt;ul&gt;
&lt;li&gt;post-processing

&lt;ul&gt;
&lt;li&gt;blur.cs.glsl&lt;/li&gt;
&lt;li&gt;dof.cs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On a ici deux applications &lt;em&gt;triangle&lt;/em&gt; et &lt;em&gt;smab&lt;/em&gt;, contenant chacune des shaders différents et partageant deux shaders de &lt;em&gt;glmlv&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Cette arborescence sera reproduite de la manière suivante dans le repertoire de build:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;opengl-avance-build

&lt;ul&gt;
&lt;li&gt;bin

&lt;ul&gt;
&lt;li&gt;triangle.exe&lt;/li&gt;
&lt;li&gt;smab.exe&lt;/li&gt;
&lt;li&gt;shaders

&lt;ul&gt;
&lt;li&gt;glmlv

&lt;ul&gt;
&lt;li&gt;post-processing

&lt;ul&gt;
&lt;li&gt;blur.cs.glsl&lt;/li&gt;
&lt;li&gt;dof.cs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;triangle

&lt;ul&gt;
&lt;li&gt;triangle.vs.glsl&lt;/li&gt;
&lt;li&gt;triangle.fs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;smab

&lt;ul&gt;
&lt;li&gt;shadow_mapping

&lt;ul&gt;
&lt;li&gt;sm.vs.glsl&lt;/li&gt;
&lt;li&gt;sm.fs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;deferred

&lt;ul&gt;
&lt;li&gt;gbuffer.vs.glsl&lt;/li&gt;
&lt;li&gt;gbuffer.fs.glsl&lt;/li&gt;
&lt;li&gt;shading.vs.glsl&lt;/li&gt;
&lt;li&gt;shading.fs.glsl&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De cette manière, un code comme le suivant accède facilement aux shaders &lt;strong&gt;sans dépendre de l&amp;rsquo;emplacement de ces derniers sur la machine de l&amp;rsquo;utilisateur&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;glmlv/filesystem.hpp&amp;gt;

// Supposons que le code est celui de smab.exe, dont le chemin est C:/toto/tata/bin/smab.exe
int main(int argc, char** argv)
{
    // argv[0] contient toujours le chemin vers l&#39;executable, ici &amp;quot;C:/toto/tata/bin/smab.exe&amp;quot;
    // On le récupère dans une variable de type glmlv::fs::path permettant de gérer facilement les chemins
    const auto applicationPath = glmlv::fs::path{ argv[0] };

    // stem() renvoit le nom du fichier sans son extension, i.e. &amp;quot;smab&amp;quot;:
    const auto appName = applicationPath.stem().string();

    // L&#39;opérateur &#39;/&#39; permet de concatener les chemins de fichier
    const auto shadersRootPath = applicationPath.parent_path() / &amp;quot;shaders&amp;quot;;

    // Pour les shaders de l&#39;application, on utilise la variable contenant le nom de l&#39;application pour accéder au dossier contenant ses shaders
    const auto pathToSMVS = shadersRootPath / appName / &amp;quot;shadow_mapping&amp;quot; / &amp;quot;sm.vs.glsl&amp;quot;;
    const auto pathToSMFS = shadersRootPath / appName / &amp;quot;shadow_mapping&amp;quot; / &amp;quot;sm.fs.glsl&amp;quot;;

    // Pour les shaders de la lib, on cible directement le dossier &amp;quot;glmlv&amp;quot;
    const auto pathToBlurCS = shadersRootPath / &amp;quot;glmlv&amp;quot; / &amp;quot;post-processing&amp;quot; / &amp;quot;blur.cs.glsl&amp;quot;;

    [...]

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;applications-d-exemple&#34;&gt;Applications d&amp;rsquo;exemple&lt;/h2&gt;

&lt;p&gt;Le repertoire &lt;em&gt;apps&lt;/em&gt; contient déjà du code pour plusieurs applications simples. Toutes sont basées sur le template de base &lt;em&gt;template&lt;/em&gt; qui se contente d&amp;rsquo;ouvrir une fenêtre contenant une GUI affichant le framerate et permettant de changer la couleur de fond.&lt;/p&gt;

&lt;p&gt;Ces codes simples sont destinés à vous donner quelques exemple d&amp;rsquo;appels aux fonctions OpenGL, en particulier l&amp;rsquo;utilisation des fonction de l&amp;rsquo;extension direct_state_access.&lt;/p&gt;

&lt;p&gt;Une ressource supplémentaire est &lt;a href=&#34;https://github.com/g-truc/ogl-samples/tree/master/tests&#34;&gt;ce repository GIT&lt;/a&gt; contenant un grand nombre d&amp;rsquo;exemples de code pour l&amp;rsquo;ensemble des features OpenGL.&lt;/p&gt;

&lt;p&gt;Voici une description des apps d&amp;rsquo;exemple:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;triangle &lt;em&gt;Dessine un triangle coloré&lt;/em&gt; (création de VBO, création de VAO, attributs entrelacés, chargement de shaders)&lt;/li&gt;
&lt;li&gt;triangle_2vbos &lt;em&gt;Pareil mais en utilisant 2 VBOs, un pour les positions, l&amp;rsquo;autre pour les couleurs&lt;/em&gt; (plusieurs VBOs pour un objet, attributs non entrelacés)&lt;/li&gt;
&lt;li&gt;quad &lt;em&gt;Dessine un quad coloré&lt;/em&gt; (création d&amp;rsquo;IBO, i.e. buffer d&amp;rsquo;index)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>OpenGL Objects</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/06-course/opengl-objects/</link>
      <pubDate>Thu, 19 Jan 2017 23:52:53 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/06-course/opengl-objects/</guid>
      <description>&lt;p&gt;Les objets OpenGL représentent des conteneurs d&amp;rsquo;état du contexte OpenGL.
Lorsqu&amp;rsquo;un objet est bindé sur l&amp;rsquo;état correspondant, tous les changement sur cet état sont stocké dans l&amp;rsquo;objet bindé.&lt;/p&gt;

&lt;p&gt;A lire: &lt;a href=&#34;https://www.khronos.org/opengl/wiki/OpenGL_Object&#34;&gt;https://www.khronos.org/opengl/wiki/OpenGL_Object&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Il existe différents types d&amp;rsquo;objets OpenGL, ceux que nous utilisons dans ces TPs étant:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Buffer_Object&#34;&gt;Buffer Object&lt;/a&gt;: représente un tableau de données pouvant être stocké en mémoire GPU.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Vertex_Specification&#34;&gt;Vertex Array Object&lt;/a&gt;: représente la spécification des sommets et leurs rangement aux seins d&amp;rsquo;un ou plusieurs buffer objets.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Texture&#34;&gt;Texture Object&lt;/a&gt;: représente une texture pouvant être stocké en mémoire GPU et pouvant être lue et filtrée depuis les shaders.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Sampler_Object&#34;&gt;Sampler Object&lt;/a&gt;: représente des paramètres de lecture et filtrage de textures.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/Framebuffer_Object&#34;&gt;Framebuffer Object&lt;/a&gt;: Représente un ensemble de textures sur lesquels il est possible de dessiner.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.khronos.org/opengl/wiki/GLSL_Object&#34;&gt;GLSL Objects&lt;/a&gt;: Shaders et programmes GLSL qui peuvent être executés par les stage programmable du GPU.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Directional SM - Utilisation</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map-usage/</link>
      <pubDate>Thu, 19 Jan 2017 23:22:21 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map-usage/</guid>
      <description>&lt;p&gt;todo.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>