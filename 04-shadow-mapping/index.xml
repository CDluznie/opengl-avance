<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>04-shadow-mappings on OpenGL Avancé</title>
    <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/index.xml</link>
    <description>Recent content in 04-shadow-mappings on OpenGL Avancé</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <lastBuildDate>Thu, 29 Dec 2016 12:09:46 +0100</lastBuildDate>
    <atom:link href="https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Shadow Mapping</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/</link>
      <pubDate>Thu, 29 Dec 2016 12:09:46 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/</guid>
      <description>

&lt;h1 id=&#34;shadow-mapping&#34;&gt;Shadow Mapping&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/introduction/</link>
      <pubDate>Thu, 29 Dec 2016 12:29:08 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/introduction/</guid>
      <description>&lt;p&gt;Nous avons jusqu&amp;rsquo;a présent calculé l&amp;rsquo;éclairage des lumières sans prise en compte des ombres portées par les objets: la lumière passe à travers&amp;hellip;&lt;/p&gt;

&lt;p&gt;Pour savoir si un fragment est dans la lumière ou dans l&amp;rsquo;ombre par rapport à une light donnée, il faut savoir si un objet intersecte le rayon connectant le fragment à la lumière. Il y a plusieurs moyens de calculer cette information. Deux méthodes sont principalement utilisées en rendu temps réel: le &lt;a href=&#34;https://www.wikiwand.com/en/Shadow_mapping&#34;&gt;shadow mapping&lt;/a&gt; et les &lt;a href=&#34;https://www.wikiwand.com/en/Shadow_volume&#34;&gt;shadow volumes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nous allons nous intéresser au shadow mapping pour ces TPs. L&amp;rsquo;idée est de faire un rendu de la scène selon le point de vue de la lumière afin de connaitre l&amp;rsquo;ensemble des points visibles depuis cette lumière. Plus exactement, on calcule une carte de profondeur (depth map) vue par la lumière. Ensuite, pendant le rendu principal de la scène (depuis le point de vue de la caméra), on projete les points vus par la caméra sur la depth map précalculée pour la light. On obtient ainsi un pixel de la depth map, et si la depth enregistrée dans cette map est inférieure à la depth du fragment vu par la caméra, alors necessairement un objet vient occulter ce fragment, qui est donc dans l&amp;rsquo;ombre.&lt;/p&gt;

&lt;p&gt;Le schéma suivant résume ce principe:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://Celeborn2BeAlive.github.io/opengl-avance/images/shadow_mapping.jpg&#34; alt=&#34;Shadow Mapping&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cet algorithme peut être implémenté sur un forward renderer ou sur un deferred renderer. Pour ces TPs nous allons repartir du deferred renderer. Si vous ne l&amp;rsquo;avez pas terminé, vous pouvez le récupérer sur la branche cheat du repository.&lt;/p&gt;

&lt;div class=&#34;notices note&#34; &gt;&lt;p&gt;Afin de faire vos tests plus rapidement, j&amp;rsquo;ai ajouté un argument à la fonction &lt;em&gt;glmlv::loadObj&lt;/em&gt; qui permet d&amp;rsquo;éviter le chargement des textures et donc de lancer plus rapidement l&amp;rsquo;application (mettre l&amp;rsquo;argument à &lt;em&gt;false&lt;/em&gt; pour ne pas charger les textures). Il faudra peut être puller la dernière version du repo pour récupérer ce changement.&lt;/p&gt;
&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Directional Shadow Map</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map/</link>
      <pubDate>Thu, 19 Jan 2017 23:22:14 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/dir-shadow-map/</guid>
      <description>

&lt;p&gt;Nous allons commencer par l&amp;rsquo;utilisation du shadow mapping pour une lumière directionnelle, qui est plus simple.&lt;/p&gt;

&lt;p&gt;Il y a globalement quatre partie à coder:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Initialisation: Allocation des données OpenGL nécessaire à l&amp;rsquo;algorithme&lt;/li&gt;
&lt;li&gt;Shaders: Coder les shaders nécessaire à la création de la shadow map.&lt;/li&gt;
&lt;li&gt;Création de la shadow map: A faire au rendu des que la direction de la lumière est modifiée. Il s&amp;rsquo;agit de calculer la depth map selon le point de vue de la light.&lt;/li&gt;
&lt;li&gt;Utilisation de la shadow map: A faire dans la shading pass. Il s&amp;rsquo;agit avant d&amp;rsquo;éclairer un fragment vu par la caméra de vérifier s&amp;rsquo;il est visible depuis la light en utilisant la depth map précalculée.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;initialisation&#34;&gt;Initialisation&lt;/h2&gt;

&lt;p&gt;Dans la classe Application, ajoutez 4 variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;GLuint m_directionalSMTexture;
GLuint m_directionalSMFBO;
GLuint m_directionalSMSampler;
int32_t m_nDirectionalSMResolution = 512;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La première est destinée à stocker un identifiant de texture OpenGL qui contiendra la depth map selon le point de vue de la light.&lt;/p&gt;

&lt;p&gt;La deuxième est destinée à stocker un identifiant de framebuffer OpenGL qui nous permettra de dessiner la depth map.&lt;/p&gt;

&lt;p&gt;La troisème est destinée à stocker un identifiant de sampler OpenGL qui nous permettra de lire la depth map depuis un shader.&lt;/p&gt;

&lt;p&gt;Enfin la dernière stocke simplement la résolution de la depth map (ici 512x512).&lt;/p&gt;

&lt;p&gt;Dans le constructeur de l&amp;rsquo;application, créez à la texture m_directionalSMTexture, de target GL_TEXTURE_2D et de format interne GL_DEPTH_COMPONENT32F.&lt;/p&gt;

&lt;p&gt;Créez le framebuffer m_directionalSMFBO et attachez lui la texture m_directionalSMTexture sur l&amp;rsquo;attachment GL_DEPTH_ATTACHMENT (voir le code de l&amp;rsquo;initialisation du GBuffer du deferred shading pour exemple).&lt;/p&gt;

&lt;p&gt;Vérifiez la validité du framebuffer, puis débindez le framebuffer.&lt;/p&gt;

&lt;p&gt;Créez enfin le sampler m_directionalSMSampler avec le code suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;glGenSamplers(1, &amp;amp;m_directionalSMSampler);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fonctions GL à utiliser:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Sans DSA&lt;/th&gt;
&lt;th&gt;DSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;glGenTextures&lt;/td&gt;
&lt;td&gt;glCreateTextures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindTexture&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glTexStorage2D&lt;/td&gt;
&lt;td&gt;glTextureStorage2D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glGenFramebuffers&lt;/td&gt;
&lt;td&gt;glCreateFramebuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glFramebufferTexture2D&lt;/td&gt;
&lt;td&gt;glNamedFramebufferTexture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glDrawBuffers&lt;/td&gt;
&lt;td&gt;glNamedFramebufferDrawBuffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glCheckFramebufferStatus&lt;/td&gt;
&lt;td&gt;glCheckNamedFramebufferStatus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glGenSamplers&lt;/td&gt;
&lt;td&gt;glCreateSamplers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;glSamplerParameteri&lt;/td&gt;
&lt;td&gt;glSamplerParameteri&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;shaders&#34;&gt;Shaders&lt;/h2&gt;

&lt;p&gt;Ajoutez deux nouveaux shaders &lt;em&gt;directionalSM.vs.glsl&lt;/em&gt; et &lt;em&gt;directionalSM.fs.glsl&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;objectif du vertex shader est de transformer le sommet d&amp;rsquo;entrée dans l&amp;rsquo;espace de la light. Pour cela, on suppose que l&amp;rsquo;application fournie une matrice ViewProjection adaptée et le code est simplement le suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;// directionalSM.vs.glsl
#version 330

layout(location = 0) in vec3 aPosition;
uniform mat4 uDirLightViewProjMatrix;

void main()
{
    gl_Position =  uDirLightViewProjMatrix * vec4(aPosition, 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le fragment shader n&amp;rsquo;a rien a faire car tout ce qui nous interesse c&amp;rsquo;est la depth des fragments. Or la depth est directement écrite par la carte graphique dans le depth buffer après l&amp;rsquo;execution du fragment shader. On se contente donc d&amp;rsquo;écrire un fragment shader minimal qui ne sort que du noir:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;// directionalSM.fs.glsl
#version 330
out vec3 fColor;
void main()
{
    fColor = vec3(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans l&amp;rsquo;application, ajoutez un nouveau programme et une variable pour stocker la location de l&amp;rsquo;uniform &lt;em&gt;uDirLightViewProjMatrix&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;glmlv::GLProgram m_directionalSMProgram;
GLint m_uDirLightViewProjMatrix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans le constructor, compilez le programme à partir des deux nouveaux shaders et récupérez à la location avec &lt;em&gt;glGetUniformLocation&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;création-de-la-shadow-map&#34;&gt;Création de la shadow map&lt;/h2&gt;

&lt;p&gt;Il faut à présent calculer la shadow map dans la boucle de rendu. Attention: ce calcul necessite un rendu de la scène, qui peut être coûteux. Il faut donc faire attention à ne recalculer la shadow map que si la light change de direction, par exemple en utilisant un booléen. La structure générale de la méthode run() devient donc:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int Application::run()
{
    [...]
    bool directionalSMDirty = true;

    // Loop until the user closes the window
    for (auto iterationCount = 0u; !m_GLFWHandle.shouldClose(); ++iterationCount)
    {
        [...]
        if (directionalSMDirty)
        {
            // Calcul de la shadow map (**)
            [...]

            directionalSMDirty = false; // Pas de calcul au prochain tour
        }

        // Rendu
        [...]

        // Pseudo code dans le dessin de la GUI:
        if (directional_light_change)
        {
            directionalSMDirty = true; // Il faut recalculer la shadow map
        }
        [...]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mettez en place cette structure de code par dessus le code actuel de rendu du deferred.&lt;/p&gt;

&lt;p&gt;A la suite du commentaire *// Calcul de la shadow map (*&lt;em&gt;)&lt;/em&gt;, ajoutez le code suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;m_directionalSMProgram.use();

glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_directionalSMFBO);
glViewport(0, 0, m_nDirectionalSMResolution, m_nDirectionalSMResolution);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

glUniformMatrix4fv(m_uDirLightViewProjMatrix, 1, GL_FALSE, glm::value_ptr(dirLightProjMatrix * dirLightViewMatrix));

glBindVertexArray(m_SceneVAO);

// We draw each shape by specifying how much indices it carries, and with an offset in the global index buffer
for (const auto shape : m_shapes) {
    glDrawElements(GL_TRIANGLES, shape.indexCount, GL_UNSIGNED_INT, (const GLvoid*)(shape.indexOffset * sizeof(GLuint)));
}

glBindVertexArray(0);

glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ce code met en place le programme pour dessiner la shadow map, bind le FBO sur lequel la shadow map est attachée, puis dessine la scène. Logiquement, après ce dessin, la texture m_directionalSMTexture (attachée à m_directionalSMFBO) doit contenir la shadow map.&lt;/p&gt;

&lt;p&gt;Dans ce code, il vous manque le calcul des deux matrices dirLightProjMatrix et dirLightViewMatrix, qui est le suivant (à faire au début de la boucle de rendu car ces variables serviront aussi à la shading pass):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static const auto computeDirectionVectorUp = [](float phiRadians, float thetaRadians)
{
    const auto cosPhi = glm::cos(phiRadians);
    const auto sinPhi = glm::sin(phiRadians);
    const auto cosTheta = glm::cos(thetaRadians);
    return -glm::normalize(glm::vec3(sinPhi * cosTheta, -glm::sin(thetaRadians), cosPhi * cosTheta));
};

const auto sceneCenter = 0.5f * (m_BBoxMin + m_BBoxMax);
const float sceneRadius = m_SceneSizeLength * 0.5f;

const auto dirLightUpVector = computeDirectionVectorUp(glm::radians(m_DirLightPhiAngleDegrees), glm::radians(m_DirLightThetaAngleDegrees));
const auto dirLightViewMatrix = glm::lookAt(sceneCenter + m_DirLightDirection * sceneRadius, sceneCenter, dirLightUpVector); // Will not work if m_DirLightDirection is colinear to lightUpVector
const auto dirLightProjMatrix = glm::ortho(-sceneRadius, sceneRadius, -sceneRadius, sceneRadius, 0.01f * sceneRadius, 2.f * sceneRadius);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La matrice de projection du lumière directionelle est orthographique car une telle lumière voit &amp;ldquo;en parallèle&amp;rdquo; (tous les points sont illuminés selon la même direction). On fait en sorte que la light voit l&amp;rsquo;ensemble de la scène en la plaçant au bord de la bounding sphere de la scène (d&amp;rsquo;ou le calcul du centre et du rayon de la scène). Il vous sera peut être necessaire de stocker m_BBoxMin et m_BBoxMax si ce n&amp;rsquo;est pas déjà fait, qui peuvent être obtenu au moment du chargement de la scène.&lt;/p&gt;

&lt;h2 id=&#34;utilisation-de-la-shadow-map&#34;&gt;Utilisation de la shadow map&lt;/h2&gt;

&lt;p&gt;Une fois la shadow map calculée, la shading pass peut l&amp;rsquo;utiliser pour calculer la visibilité d&amp;rsquo;un fragment pour la light concernée.&lt;/p&gt;

&lt;p&gt;Il faut tout d&amp;rsquo;abord modifier le fragment shader de la shading pass (shadingPass.fs.glsl) afin d&amp;rsquo;utiliser la shadow map.
Ajoutez les uniform suivantes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform mat4 uDirLightViewProjMatrix;
uniform sampler2D uDirLightShadowMap;
uniform float uDirLightShadowMapBias;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La matrice permet de passer les fragment vus par la caméra dans l&amp;rsquo;espace projeté de la light. Une fois cette projection faite, on peut lire dans la shadow map pour obtenir la depth enregistrée dans le pixel concerné. Cette depth doit alors être comparée à la depth du fragment courant, toujours selon le point de vue de la light, pour savoir s&amp;rsquo;il est visible depuis la light.&lt;/p&gt;

&lt;p&gt;Le code est le suivant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;vec4 positionInDirLightScreen = uDirLightViewProjMatrix * vec4(position, 1);
vec3 positionInDirLightNDC = vec3(positionInDirLightScreen / positionInDirLightScreen.w) * 0.5 + 0.5;
float depthBlockerInDirSpace = texture(uDirLightShadowMap, positionInDirLightNDC.xy).r;
float dirLightVisibility = positionInDirLightNDC.z &amp;lt; depthBlockerInDirSpace + uDirLightShadowMapBias ? 1.0 : 0.0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La première ligne applique la matrice pour projeter la position du fragment courant.&lt;/p&gt;

&lt;p&gt;La deuxième light homogénise cette position projetée en divisant par la coordonnée &amp;ldquo;w&amp;rdquo;. A l&amp;rsquo;issue de cette opération, toutes les coordonnées sont entre -1 et 1. Afin de pouvoir lire dans la shadow map, on les ramène entre 0 et 1 grace au *0.5 + 0.5. Les coordonnées .xy identifie le pixel à lire dans la shadow map, et la coordonnée .z stocke la depth du fragment selon le point de vue de la light.&lt;/p&gt;

&lt;p&gt;La troisème ligne lit la depth stockée dans la shadow map à la position du fragment.&lt;/p&gt;

&lt;p&gt;Enfin la dernière ligne compare la depth stockée à la depth du fragment afin de savoir si la light est visible.&lt;/p&gt;

&lt;p&gt;On rajoute un biais uDirLightShadowMapBias afin d&amp;rsquo;éviter les erreurs d&amp;rsquo;imprecision numériques qui apparaissent sous la forme de &amp;ldquo;shadow acnée&amp;rdquo; (mettez ce bias a 0 initialement pour voir le problème).&lt;/p&gt;

&lt;p&gt;La variable dirLightVisibility vaut 0 si le fragment est occulté depuis la ligne, 1 sinon. Multipliez cette variable à la contribution de la lumière directionnelle afin de l&amp;rsquo;ajouter dans fColor.&lt;/p&gt;

&lt;p&gt;Une fois les modifications effectuées sur le shader, modifier le code de l&amp;rsquo;application pour récupérer la location des nouvelles uniformes. Dans la boucle de rendu, settez ces uniforms correctement et bindez la texture de shadow map m_directionalSMTexture ainsi que le sampler m_directionalSMSampler sur une nouvelle texture unit (non utilisée par le GBuffer). Pour le uDirLightShadowMapBias, faites en sorte qu&amp;rsquo;il soit controlable depuis la GUI.&lt;/p&gt;

&lt;p&gt;Enfin il y a un piège pour la matrice uDirLightViewProjMatrix. Le code est un peu différent de la passe précédente puisqu&amp;rsquo;il ne suffit de pas multiplier dirLightProjMatrix à dirLightViewMatrix pour obtenir cette matrice.&lt;/p&gt;

&lt;p&gt;Cela est du au fait que les fragments de la shading pass ne sont pas en espace World mais en espace View de la caméra. Il faut donc qu&amp;rsquo;ils soient repassés en World avant d&amp;rsquo;être transformés dans l&amp;rsquo;espace de la light. Pour cela, il suffit de multiplier à gauche par l&amp;rsquo;inverse de la View matrix de la caméra:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const auto rcpViewMatrix = m_viewController.getRcpViewMatrix(); // Inverse de la view matrix de la caméra
glUniformMatrix4fv(m_uDirLightViewProjMatrix_shadingPass, 1, GL_FALSE, glm::value_ptr(dirLightProjMatrix * dirLightViewMatrix * rcpViewMatrix));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;si-ça-ne-fonctionne-pas&#34;&gt;Si ça ne fonctionne pas&lt;/h2&gt;

&lt;p&gt;A ce stade, votre shadow mapping devrait fonctionner et vous devriez donc voir les ombres portées par les objets de la scène par rapport à la lumière directionnelle.&lt;/p&gt;

&lt;p&gt;Néammoins, il peut exister une multitude de raisons pour lesquelles un shadow mapping ne fonctionnerait pas immédiatement (c&amp;rsquo;est d&amp;rsquo;ailleur rare qu&amp;rsquo;il fonctionne du premier coup).&lt;/p&gt;

&lt;p&gt;Afin de débogguer, une première approche peut être d&amp;rsquo;afficher la depth map vue par la caméra. Malheureusement, la depth map ne peut pas être blittée à l&amp;rsquo;ecran comme les autres textures du GBuffer.&lt;/p&gt;

&lt;p&gt;Il faut donc coder un fragment shader dediée à l&amp;rsquo;affichage de la depth map:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;// displayDepth.fs.glsl
#version 330

uniform sampler2D uGDepth;

out vec3 fColor;

void main()
{
    float depth = texelFetch(uGDepth, ivec2(gl_FragCoord.xy), 0).r;
    fColor = vec3(depth); // Since the depth is between 0 and 1, pow it to darkness its value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ce fragment shader peut être combiné à &lt;em&gt;shadingPass.vs.glsl&lt;/em&gt; pour former un programme GLSL. En bindant correctment la depth map à afficher, et en dessinant un triangle sur tout l&amp;rsquo;ecran, on peut ainsi afficher n&amp;rsquo;importance quel depth map (en particulier celle représentant la shadow map de la light).&lt;/p&gt;

&lt;p&gt;Voir sur la branche cheat pour un exemple.&lt;/p&gt;

&lt;h2 id=&#34;percentage-closest-filtering&#34;&gt;Percentage Closest Filtering&lt;/h2&gt;

&lt;h3 id=&#34;basique&#34;&gt;Basique&lt;/h3&gt;

&lt;p&gt;L&amp;rsquo;aspect visuel du shadow mapping dépend grandement de la résolution choisie. Pour une résolution de 512, vous avez du constater que le rendu des ombres est très aliasé. Il faut monter à 4096 au moins pour ne plus voir l&amp;rsquo;aliasing à une distance correcte, qui reste très visible en se rapprochant.&lt;/p&gt;

&lt;p&gt;Une manière de palier à cet aliasing est d&amp;rsquo;utiliser une méthode de filtrage appelée &lt;em&gt;Percentage Closest Filtering&lt;/em&gt;, qui consiste à moyenner la visibilité dans un voisinage du point afin de flouter/bruiter les ombres sur leur bord.&lt;/p&gt;

&lt;p&gt;Cette technique est en partie supportée par le GPU en passant par un sampler de type &lt;em&gt;sampler2DShadow&lt;/em&gt; en GLSL.&lt;/p&gt;

&lt;p&gt;Dans &lt;em&gt;shadingPass.fs.glsl&lt;/em&gt;, remplacez la déclaration des uniformes du shadow mapping par:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform mat4 uDirLightViewProjMatrix;
uniform sampler2DShadow uDirLightShadowMap;
uniform float uDirLightShadowMapBias;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Puis remplacez le code de calcul de la visibilité par:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;vec4 positionInDirLightScreen = uDirLightViewProjMatrix * vec4(position, 1); // Compute fragment position in NDC space of light
vec3 positionInDirLightNDC = vec3(positionInDirLightScreen / positionInDirLightScreen.w) * 0.5 + 0.5; // Homogeneize + put between 0 and 1
float dirLightVisibility = textureProj(uDirLightShadowMap, vec4(positionInDirLightNDC.xy, positionInDirLightNDC.z - uDirLightShadowMapBias, 1.0), 0.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On utilise donc un &lt;em&gt;sampler2DShadow&lt;/em&gt; à la place d&amp;rsquo;un &lt;em&gt;sampler2D&lt;/em&gt; et la fonction &lt;em&gt;textureProj&lt;/em&gt; à la place de &lt;em&gt;texture&lt;/em&gt;. Ce code permet d&amp;rsquo;obtenir un filtrage 2x2 (bilinéaire) sur nos ombres.&lt;/p&gt;

&lt;p&gt;Afin que ce shader fonctionne, il faut rajouter deux lignes à l&amp;rsquo;initialisation du sampler m_directionalSMSampler:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;glGenSamplers(1, &amp;amp;m_directionalSMSampler);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE); // Cette ligne
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL) // Et celle ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ces lignes définissent le comportement de la fonction &lt;em&gt;textureProj&lt;/em&gt; dans le shader.&lt;/p&gt;

&lt;p&gt;Une fois ces modifications effectuées, lancez votre application et constatez que les ombres sont un peu floutées.&lt;/p&gt;

&lt;h3 id=&#34;arbitraire&#34;&gt;Arbitraire&lt;/h3&gt;

&lt;p&gt;Il est possible d&amp;rsquo;allouer plus loin dans le filtrage des ombres en appliquant un filtre arbitraire lors de la lecture de la shadow map. Cela est plus couteux mais également plus agréable visuellement.&lt;/p&gt;

&lt;p&gt;Dans &lt;em&gt;shadingPass.fs.glsl&lt;/em&gt;, ajoutez les uniform:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;uniform int uDirLightShadowMapSampleCount;
uniform float uDirLightShadowMapSpread;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;et le code utilitaires (avant le main):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;vec2 poissonDisk[16] = vec2[](
    vec2( -0.94201624, -0.39906216 ),
    vec2( 0.94558609, -0.76890725 ),
    vec2( -0.094184101, -0.92938870 ),
    vec2( 0.34495938, 0.29387760 ),
    vec2( -0.91588581, 0.45771432 ),
    vec2( -0.81544232, -0.87912464 ),
    vec2( -0.38277543, 0.27676845 ),
    vec2( 0.97484398, 0.75648379 ),
    vec2( 0.44323325, -0.97511554 ),
    vec2( 0.53742981, -0.47373420 ),
    vec2( -0.26496911, -0.41893023 ),
    vec2( 0.79197514, 0.19090188 ),
    vec2( -0.24188840, 0.99706507 ),
    vec2( -0.81409955, 0.91437590 ),
    vec2( 0.19984126, 0.78641367 ),
    vec2( 0.14383161, -0.14100790 )
);

float random(vec4 seed)
{
    float dot_product = dot(seed, vec4(12.9898,78.233,45.164,94.673));
    return fract(sin(dot_product) * 43758.5453);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le tableau poissonDisk definit 16 échantillons d&amp;rsquo;une distribution de poisson 2D centrée en (0,0). La fonction random permet d&amp;rsquo;obtenir un nombre pseudo-aléatoire à partir d&amp;rsquo;une graine.&lt;/p&gt;

&lt;p&gt;Dans le main du shader, remplacez le calcul de la visibilité par:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;float dirLightVisibility = 0.0;
float dirSampleCountf = float(uDirLightShadowMapSampleCount);
int step = max(1, 16 / uDirLightShadowMapSampleCount);
for (int i = 0; i &amp;lt; uDirLightShadowMapSampleCount; ++i)
{
    // Noisy shadows:
    int index = int(dirSampleCountf * random(vec4(gl_FragCoord.xyy, i))) % uDirLightShadowMapSampleCount;

    dirLightVisibility += textureProj(uDirLightShadowMap, vec4(positionInDirLightNDC.xy + uDirLightShadowMapSpread * poissonDisk[index], positionInDirLightNDC.z - uDirLightShadowMapBias, 1.0), 0.0);
}
dirLightVisibility /= dirSampleCountf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dans le code de l&amp;rsquo;application, faites en sorte de pouvoir setter les deux nouvelles uniforms uDirLightShadowMapSampleCount et uDirLightShadowMapSpread via la GUI. La variable uDirLightShadowMapSpread doit être relativement petite (de l&amp;rsquo;ordre de 0.0005) afin de ne pas trop disperser les ombres.&lt;/p&gt;

&lt;p&gt;Essayez ce code. Il devrait vous donner des ombres bruitées mais douces.&lt;/p&gt;

&lt;p&gt;Une alternative pour obtenir des ombres floutées plutot que bruitées est de calculer l&amp;rsquo;index dans la boucle avec:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;// Blurred shadows:
int index = (i + step) % uDirLightShadowMapSampleCount;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Point Shadow Map</title>
      <link>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/point-shadow-map/</link>
      <pubDate>Thu, 19 Jan 2017 23:22:33 +0100</pubDate>
      
      <guid>https://celeborn2bealive.github.io/opengl-avance/04-shadow-mapping/point-shadow-map/</guid>
      <description>&lt;p&gt;todo.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>